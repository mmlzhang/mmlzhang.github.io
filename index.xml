<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页 on 工具书-mlzhang</title><link>http://lanms.github.io/</link><description>Recent content in 首页 on 工具书-mlzhang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 30 Apr 2022 16:55:47 +0000</lastBuildDate><atom:link href="http://lanms.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a New Theme</title><link>http://lanms.github.io/posts/creating-a-new-theme/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>http://lanms.github.io/posts/creating-a-new-theme/</guid><description>Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>http://lanms.github.io/posts/migrate-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>http://lanms.github.io/posts/migrate-from-jekyll/</guid><description>Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title/><link>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid><description>安装hugo # brew install hugo 创建项目 # hugo new site mlzhang_wiki cd mlzhang_wiki git init # 安装主题 git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book hugo mod init github.com/repo/path # config.toml 添加 [module] [[module.imports]] path = &amp;#39;github.com/alex-shpak/hugo-book&amp;#39; # 拷贝示例 cp -R themes/hugo-book/exampleSite/content . 启动本地服务 # hugo server -D</description></item><item><title/><link>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/github%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/github%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1/</guid><description>托管到Github Pages # 参考文档：
https://zhuanlan.zhihu.com/p/350977057 对于托管到Github Pages，官方文档写的不是那么特别清楚，实际上是非常简单的。
因为是博客，所以遵循Github Pages的规则，项目名称就是username.github.io，建一个这样名字的库，权限设置为public，默认选项一个都不要勾选，建完了以后，就会看到这样一个界面。
我们前文已经初始化过git库了，所以这里我们只要把远程库的地址加进来就好了。
在这之前，先随便创建一个README.md文件，一会儿用得到它。
studyhugo $ echo &amp;#34;# Blog Contructing......&amp;#34; &amp;gt;&amp;gt; README.md 然后创建master分支
studyhugo $ git add . studyhugo $ git branch -M master studyhugo $ git commit -m &amp;#34;Initial Commit&amp;#34; studyhugo $ git remote add origin git@github.com:username/username.github.io.git 然后push上去。
studyhugo $ git push 到Github上看到我们Hugo站点源文件已经push上来了。
对于username.github.io这样的项目名，Github会直接认定为Github Pages并发布。所以现在已经可以访问https://username.github.io。
当然，因为Github Pages并不直接支持Hugo站点的发布，所以它发布了我们添加进去的README.md文件。
接下来我们就要添加Github Action，Hugo官方已经给我们准备好了，我们自己要做的事很少，参考官方文档的这一节。
官方提供了一个yml文件，文件应该存在.github/workflows/gh-pages.yml里。
在项目的选项里选择Actions——
点进去以后是这样子的——
把这里的文件名改成gh-pages.yml，删掉当前的内容，然后把官方提供的代码拷贝进来，注意这里官方的代码部署用的分支是main，而我们的是master，要对应的改掉。
name: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.</description></item><item><title/><link>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E6%B7%BB%E5%8A%A0%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E6%B7%BB%E5%8A%A0%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</guid><description>使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages # 参考链接
https://cloud.tencent.com/developer/article/1834163 hugo博客搭建好了，但访问的时候只能是以固定的域名形式（用户名.github.io）进行访问。这时可以通过购买域名的方式行实现自定义域名访问。可以去国外买或者国内，国内都是需要备案的。
https://sg.godaddy.com/zh例如这个就是国外购买域名的网站，直接购买即可。如果是国内的话需要购买域名和服务器或主机才能备案。
购买域名后：
第一步 # 首先是用ping命令找到存放你的github pages的主机的IP地址，在终端里面用命令ping xxx.github.io便可完成，下图中红框内的就是我们要找的IP地址：
第二步 # 在购买域名的提供商为域名添加解析。我是在阿里云买的域名，因此我以阿里云的为例。在域名控制台选择想要绑定的域名，并点击解析：
然后添加如下两条记录：
记录类型：CNAME 将一个域名指向例外一个域名，再由另一个域名提供 IP 地址，就需要添加 CNAME 记录。 主机记录：www 表示访问域名的时候以www开头为一级域名。如果是二级域名的话就在前面加上自己想要的参数，访问的时候也是以二级域名的形式访问。 记录类型：A 将域名指向一个IPv4地址，如果需要将域名指向一个 IP 地址（外网地址），就需要添加 A 记录。 主机记录：@ 表示访问的时候直接用 yunxdr.top 形式 访问，前面不加任何参数。如果是www，就要以 www.yunxdr.top 访问。这里设置的@形式与下面GitHub上自定义的域名要对应 第三步 # 在上面存放静态网站的Repository Settings里面GitHubPages Custom domain（自定义域名）填上自己的域名点击save； 设置完成后就可以通过 yunxdr.top 访问部署在GitHub上的hugo的网站了
例外如果不太懂解析域名的可以参考如下资料：
关于记录值www和@的区别
创建 www.dns-example.com 的子域名。 创建 dns-example.</description></item><item><title>00-Python设计模式介绍</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</guid><description>简介 # Python的设计模式可以分为三大类，创建型模式，结构型模式，行为型模式
创建型模式 # 介绍处理对象创建的设计模式，具体有：
工厂模式 建造者模式 原型模式 结构型模式 # 介绍处理一个系统中不同实体（类、对象等）之间的关系，具体有：
适配器模式 修饰器模式 外观模式 享元模式 模型-视图-控制器模式 代理模式 行为型模式 # 介绍处理系统实体之间通信的设计模式，具体有：
责任链模式 命令模式 解释器模式 观察者模式 状态模式 策略模式 模板模式</description></item><item><title>01-CentOS7安装docker</title><link>http://lanms.github.io/docs/14-docker/01-centos7%E5%AE%89%E8%A3%85docker/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/14-docker/01-centos7%E5%AE%89%E8%A3%85docker/</guid><description>CentOS 7 安装docker # yum update
vim /etc/yum.repos.d/docker.repo
[dockerrepo] name=Docker Repository baseurl=https://yum.dockerproject.org/repo/main/centos/7/ enabled=1 gpgcheck=1 gpgkey=https://yum.dockerproject.org/gpg yum install docker-engine 安装docker包
systemctl start docker 启动docker服务
mkdir /etc/systemd/system/docker.service.d
vim /etc/sysytemd/system/docker.service.d/http-proxy.conf # 添加代理
[Service] Enviroment=”HTTP_PROXY=http://用户名：密码@代理地址：端口号” 例子 [Service] Environment=&amp;#34;HTTP_PROXY=http://proxy.ip.com:80&amp;#34;</description></item><item><title>01-git_flow工作流使用指南</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/01-git_flow%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/01-git_flow%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid><description>Git Flow使用方法 # git flow是一个git的扩展集。Git flow 可以工作在 OSX, Linux 和 Windows之下。 本文主要列举一些常用的git flow命令。以及git flow从无到有的步骤；
安装。 初始化。 git flow init 最后就一路回车选择默认的就ok了，，接下来就是使用了 常用命令以及分支：
分支介绍：
master。 只有一个，并且不会在master上进行代码的操作。 develop。 只有一个，新特性的开发是基于develop开发的，但是不能直接在develop上进行开发，而是在基于develop上创建feature分支进行新特性的开发。 feature。 可以同时存在多个，基于develop分支被创建。对于每一个新的功能可以创建一个新的feature分支，开发结束之后，合并到develop分支即可。 创建一个新的feature分支，命令：git flow feature start name 执行之后，feature/name分支就会被创建。 当新特性开发完成过后，需要合并到develop上，命令:git flow feature finish name 执行之后，feature/name分支的内容就会合并到develop，，并且删除feature/name分支。 release分支。 release分支是为了发布而存在的分支，基于develop分支被创建。在同一时间只能有一个release分支，在此分支上仅仅是较少代码的修复。否则，容易引起release分支不稳定。当release分支被创建之后，develop分支可能在准备另一个版本的，因此，当release分支merge回develop分支时候可能会出现冲突，需要手工解决冲突。 创建一个release分支，命令：git flow release start v.1.0 当完成release分支功能之后，执行命令：git flow release finish v.1.0。这个命令会执行一下的操作：（1.分支merge回master分支；2.使用release分支名称打tag；3.release分支merge回develop分支；4.删除release分支。） hotfix分支。 当发现master分支出现一个需要紧急修复的bug，这个时候就需要使用hotfix。基于master分支被创建。同一时间只有一个hotfix分支，生命周期比较短。 创建hotfix分支。命令：git flow hotfix start v.</description></item><item><title>01-Git基本用法和工作流程</title><link>http://lanms.github.io/docs/03-git/01-git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/01-git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid><description>windows git操作 # 主要流程 # windows本地操作 git init (第一次要设置user.name, user.email) git add . git status git commit -m &amp;#34;修改说明&amp;#34; git remote add origin &amp;lt;远端仓库url&amp;gt; git push origin master 同步到远端 git pull 从远端下载版本到本地 远端克隆到本地 git clone &amp;lt;远端仓库的url&amp;gt; cd 仓库名 进入克隆下的仓库 git branch &amp;lt;分支名&amp;gt; 创建自己的分支修改文件 git branch -d &amp;lt;分支名&amp;gt; 删除分支 git checkout &amp;lt;分支名&amp;gt; 切换分支 修改本地文件 git add . git status (查看一下状态) git commit -m &amp;#34;修改描述&amp;#34; git remote add origin &amp;lt;远端的url&amp;gt; git push origin master &amp;lt;上传&amp;gt; 一般是以分支提交的,以master提交会覆盖主分支 git pull &amp;lt;下载远端同步&amp;gt; 合并分支, 合并前先切换到 master 里 git merge &amp;lt;分支名&amp;gt; 默认的会将分支合并道 master里 日志 git log --online 用 --graph 选项，查看历史中什么时候出现了分支、合并 git init 将文件夹变文本地仓库 notepad test.</description></item><item><title>01-HTML标签和CSS样式表</title><link>http://lanms.github.io/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/01-html%E6%A0%87%E7%AD%BE%E5%92%8Ccss%E6%A0%B7%E5%BC%8F%E8%A1%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/01-html%E6%A0%87%E7%AD%BE%E5%92%8Ccss%E6%A0%B7%E5%BC%8F%E8%A1%A8/</guid><description>1.常用的标签 # 文本
h1 - h6 / p / hr / br / sup / sub / em / strong 列表
ul-li / ol-li / dl/ dt / dd table-th-tr-td-caption(rowspan/colspan) 图像
image(src=&amp;rsquo;&amp;rsquo; alt=&amp;rsquo;') 音频视屏
audio/source controls autoplay loop vidieo / source &amp;lt;audio controls autoplay loop&amp;gt; 区域
div / span 表单</description></item><item><title>01-Linux操作,阿里云主机</title><link>http://lanms.github.io/docs/05-linux/01-linux%E6%93%8D%E4%BD%9C%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/01-linux%E6%93%8D%E4%BD%9C%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/</guid><description>Linux命令和操作方法 # linux介绍 # Linux 的内核是开源的 下载 kernel.org 网站下载 开源内核 第二位(中间)是偶数是稳定版本 linux &amp;ndash;&amp;gt; 基于 MINIX &amp;ndash; &amp;gt; 基于 UniX Linux 是通用操作系统 第一台计算机 &amp;ndash;&amp;gt; 帕斯卡发明的 Pascal 17岁 第一台数字计算机 &amp;mdash;差分机&amp;mdash;没有软件只有硬件 &amp;ndash; 第一个程序员Ada 第一台电子数字计算机 - ENIAC - 图灵 程序员 &amp;ndash;死于一个毒苹果 &amp;ndash;苹果Logo 纪念它 内核是Linux Linux发行版本 Redhat Linux Ubantu Nginx -可以把阿里云变为 Web 服务器 MySQL -关系型数据库 -持久化数据
Redis - 非关系型数据库 FTP Mail 防火墙 iptables /filewalls 1.操作命令介绍 # root 提示符是 #, 普通用户是 $</description></item><item><title>01-tensorflow环境搭建</title><link>http://lanms.github.io/docs/13-tensorflow/01-tensorflow%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/13-tensorflow/01-tensorflow%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>01-tensorflow环境搭建 # tf 的主要依赖 # 1. Protocol Buffer # 一款谷歌开发的处理结构化数据的工具，处了Protocol Buffer 外还有 XML / JSON等结构化数据处理工具 其序列化后的数据是二进制流，需要先定义数据的格式（schema） 数据占用空间小，解析时间快 文件格式 .proto，每个 message 代表了一类结构化的数据 message user{ optional string name = 1; required int32 id = 2; repeated string email = 3;}如上：message 里定义了每一个属性的类型和名字。
Bazel # 谷歌开源的自动化构建工具，谷歌内部绝大部分的应用都是通过它来编译的 安装
pip install tensorflow
建议使用 anaconda
conda install tensorflow</description></item><item><title>01-基础开始tornado</title><link>http://lanms.github.io/docs/08-tornado/01-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8Btornado/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/08-tornado/01-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8Btornado/</guid><description>Tornado简介 # Tornado全称Tornado Web Server，是一个用Python语言写成的Web服务器兼Web应用框架，由FriendFeed公司在自己的网站FriendFeed中使用，被Facebook收购以后框架在2009年9月以开源软件形式开放给大众。
特点：
作为Web框架，是一个轻量级的Web框架，类似于另一个Python web框架Web.py，其拥有异步非阻塞IO的处理方式。 作为Web服务器，Tornado有较为出色的抗负载能力，官方用nginx反向代理的方式部署Tornado和其它Python web应用框架进行对比，结果最大浏览量超过第二名近40%。 Tornado的特性 # HTTP服务器 # Tornado为了高效实现Comet/后端异步调用HTTP接口，是直接内嵌了HTTP服务器。
前端无需加apache / lighttpd / nginx等也可以供浏览器访问；但它并没有完整实现HTTP 1.1的协议，所以官方文档是推荐用户在生产环境下在前端使用nginx，后端反向代理到多个Tornado实例。
Tornado本身是单线程的异步网络程序，它默认启动时，会根据CPU数量运行多个实例；充分利用CPU多核的优势。
单线程异步 # 网站基本都会有数据库操作，而Tornado是单线程的，这意味着如果数据库查询返回过慢，整个服务器响应会被堵塞。
数据库查询，实质上也是远程的网络调用；理想情况下，是将这些操作也封装成为异步的；但Tornado对此并没有提供任何支持。
这是Tornado的设计，而不是缺陷。
一个系统，要满足高流量；是必须解决数据库查询速度问题的！
数据库若存在查询性能问题，整个系统无论如何优化，数据库都会是瓶颈，拖慢整个系统！
异步并不能从本质上提到系统的性能；它仅仅是避免多余的网络响应等待，以及切换线程的CPU耗费。
如果数据库查询响应太慢，需要解决的是数据库的性能问题；而不是调用数据库的前端Web应用。
对于实时返回的数据查询，理想情况下需要确保所有数据都在内存中，数据库硬盘IO应该为0；这样的查询才能足够快；而如果数据库查询足够快，那么前端web应用也就无将数据查询封装为异步的必要。
就算是使用协程，异步程序对于同步程序始终还是会提高复杂性；需要衡量的是处理这些额外复杂性是否值得。
如果后端有查询实在是太慢，无法绕过，Tornaod的建议是将这些查询在后端封装独立封装成为HTTP接口，然后使用Tornado内置的异步HTTP客户端进行调用。
开始 tornado 项目 # # -*-coding: utf-8 -*- import tornado.web import tornado.ioloop # 引入 httpserver 模块 import tornado.httpserver class IndexHandler(tornado.web.RequestHandler): def get(self, *args, **kwargs): self.</description></item><item><title>01-字符串操作-os文件操作-时间日期对象-面向对象-这正则</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-os%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%99%E6%AD%A3%E5%88%99/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-os%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%99%E6%AD%A3%E5%88%99/</guid><description>1. str 字符串操作 # 常见的字符串函数 zip l = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;] b = zip(l[:-1], l[1:]) print(dict(b)) # 可以映射成字典,元组,列表 {&amp;#39;a&amp;#39;: &amp;#39;b&amp;#39;, &amp;#39;b&amp;#39;: &amp;#39;c&amp;#39;, &amp;#39;c&amp;#39;: &amp;#39;d&amp;#39;, &amp;#39;d&amp;#39;: &amp;#39;e&amp;#39;, &amp;#39;e&amp;#39;: &amp;#39;f&amp;#39;} str1.split()： 过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 str1.splitlines(): 按照行(&amp;#39;\r&amp;#39;, &amp;#39;\r\n&amp;#39;, \n&amp;#39;)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 str1.join(): 用于将序列中的元素以指定的字符连接生成一个新的字符串。 max(): 返回给定参数的最大值，参数可以为序列 min(): 返回字符串中最小的字母。 str1.replace(old, new[, max]): 把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 str1.</description></item><item><title>01-工厂模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>01-工厂模式
介绍 # 在工厂模式中，客户端可以请求一个对象，而无需知道这个对象来自哪里，也就是，使用那个类来生成这个对象，共仓背后的思想是简化对象的创建，与客户端自己基于类实例化直接创建对象相比，基于一个中心化函数来实现，更易于追踪创建了那些对象，通过将创建对象的代码和使用对象的代码解耦，工厂能够降低应用维护的复杂度。
工厂通常由两种方式，一种是工厂方法，它是一个方法，对不同的输入参数返回不同的对象，第二种是抽象工厂，它是一组用于创建一系列相关事务的工厂方法
1. 工厂方法 # 案例：Django框架工厂方法来创建表单字段，Django的forms模块支持不同类型的字段（CharField, EmailField）的创建和定制（max_length, required）。
何时使用 # 如果因为应用创建对象的代码分布在多个不同的地方，而不是仅在一个函数/方法中，你发现没法跟踪这些对象，那么因该考虑使用工厂方法模式
代码示例 https://github.com/lanms/Python_design_pattern/blob/master/01_factory_pattern/factory_method.py
2. 抽象工厂 # 抽象工厂设计模式是抽象方法的一种泛化
抽象工厂有一个有点，在使用工厂方法时从用户的视角通常是看不到的，那么就是抽象工厂能够通过改变激活的工厂方法动态的改变应用行为。
何时使用 # 通常一开始使用的是工厂方法，因为它更加简单，如果后来发现应用需要许多工厂方法，那么将创建一系列对象的过程合并在一起，而最终引入抽象方法。
代码示例https://github.com/lanms/Python_design_pattern/blob/master/01_factory_pattern/abstract_factory.py</description></item><item><title>02-Docker常用命令</title><link>http://lanms.github.io/docs/14-docker/02-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/14-docker/02-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>常用命令
service docker start / stop / restart # 启动 停止 重启 docker images #　查看多有的镜像 docker ps # 查看已启动的容器列表 docker ps -a # 查看docker创建的所有容器 docker创建一个容器
docker run -it -v /docker_test:/yufei --name docker_name -i: 允许对容器内的（STDIN)进行交互 -t: 在新容器内指定一个伪终端或终端 -v: 挂载宿主机的目录， /docker_test是宿机目录，/yufei是当前docker容器的目录，宿机必须是绝对的 --name: 容器的名称，如果省略将会随机产生一个名字 docker启动、停止、重启某个容器
docker start container_name dcoker stop container_name dcokre restart container_name 查看指定容器的日志记录
docker logs -f container_name 删除某个容器
docker rm container_name 删除全部容器
docker rm $(docker ps -a -q) 删除镜像
docker rmi image_name dcoker rmi -f $(docker images) 指定端口映射启动镜像</description></item><item><title>02-Git进阶</title><link>http://lanms.github.io/docs/03-git/02-git%E8%BF%9B%E9%98%B6/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/02-git%E8%BF%9B%E9%98%B6/</guid><description>1.git push -u origin master # 由于远程仓库是空的,第一次推送master分支时, 加上 -u , git 不但会把本地的master分支内容推送到远程的新的master分支,还会把本地的master分支和远程的master分支关联起来, 在以后推送或者拉取时就可以简化命令 git checkout -b zhang # 创建分支并切换到分支 git branch zhang git checkout zhang git branch -d zhang # 删除分支 zhang git merge zhang # 合并分支 2.分支合并冲突 # git log --graph #查看分支合并图 3.撤销缓存区的内容 # git rm --cached &amp;lt;file&amp;gt;
4.暂存分支任务 # git branch # 当前在zhang分支工作 git stash # 将当前分支暂时&amp;#39;储藏起来&amp;#39;, 等完成别的分支任务之后对其进行恢复 git checkout master # 切换到master分支 git checkout -b bug-101 # 创建新的修复bug的分支 完成修复任务后 git add .</description></item><item><title>02-Javascript-JQuary-Ajax</title><link>http://lanms.github.io/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/02-javascript-jquary-ajax/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/02-javascript-jquary-ajax/</guid><description>浏览器对象模型-BOM(Browser Object Model)
文档对象模型-DOM(Document Object Model)
语法规范 ECMScripts - 主要使用 ES 5.1 (最新是ES 8)
1.Javascript常用的命令 # 示例代码可在这篇笔记中查找, 这里是整理过后的一些总结
windonw alter / promote / confirm location href / reload() / replace() history go() / forward() / back() setTimeout()/setInterval() clearTiameout()/clearInterval() document getElementById() / TagName() / ClassName() querySelector() / querySelectorAll() textContent (文本)/ innerHTML(文本+标签) / nodeValue(节点) 图片处理, 抠图 background: url(img/url.jpg) norepeat -95px -15px;位置 事件冒泡和事件捕获 事件冒泡: child &amp;ndash;&amp;gt; parent 从下往上传播 (IE) 事件捕获: parent &amp;ndash;&amp;gt; child 从上往下传播 阻止事件的传播 evt.</description></item><item><title>02-jenkins配置指南01</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/02-jenkins%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%9701/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/02-jenkins%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%9701/</guid><description>一、Windows环境中安装Jenkins # 在最简单的情况下，Jenkins 只需要两个步骤：
1、下载最新的版本（一个 WAR 文件）。Jenkins官方网址: http://Jenkins-ci.org/
2、命运行运行 java -jar jenkins.war　（默认情况下端口是8080，如果要使用其他端口启动，可以通过命令行”java –jar Jenkins.war &amp;ndash;httpPort=80”的方式修改）
注意：Jenkins 需要运行 Java 5以及以上的版本。
还有一种安装方式就是将下载的war包文件部署到 servlet 容器，然后启动容器，在浏览器的URL地址栏中输入类似http://localhost:8080/jenkins/这样的地址即可。下图是安装成功后的界面（使用的是Linux+Tomcat6+Java6环境）：
二、Jenkins配置 # 在配置前的一些话：Jenkins的配置不可能全部都说到的，大部分配置是有英文说明的，点击输入框后面的问号就可以看见了。英文不会用翻译工具，多测试几次，你就懂了。
2.1 系统管理 # 在已运行的Jenkins主页中，点击左侧的系统管理进入如下界面：
2.1.1 提示信息 # Ps：版本不同提示的消息有可能不同
2.1.1.1 Utf-8编码 # Your container doesn&amp;rsquo;t use UTF-8 to decode URLs. If you use non-ASCII characters as a job name etc, this will cause problems. See Containers and Tomcat i18n for more details.</description></item><item><title>02-Linux安装软件服务器,防火墙</title><link>http://lanms.github.io/docs/05-linux/02-linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E7%81%AB%E5%A2%99/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/02-linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E7%81%AB%E5%A2%99/</guid><description>在Linux系统下使用 npm yum rpm nginx Linux防火墙 firewall 去IOE运动
注册软链接， 和添加系统环境变量 # yum / rpm 压缩文件安装tar.gz / tar.xz -src 源代码构建安装 make &amp;amp;&amp;amp; make install - bin 注册环境变量安装 重启服务器会失效 解压后有 bin 文件有二进制程序可以跑 但是韩式要注册path环境变量将 bin 复制到path环境变量中 echo $PATH(查看环境变量) root: export PATH=$PATH:+bin的目录 增加 永久有效 查看 ~ 所有文件 隐藏文件.bash_profile文件 vim .bash_profile 在 PATH 里添加 bin文件目录 hell.sh shell 脚本格式文件 实现自动化操作 写入命令 更改为可执行格式 +x 然后执行 安装软件
yum # yum yellowdog upgrade modified 包管理工具 前身 rpm redhat package manager yum 服务器仓库 yum list insatlled | grep Nginx yum search Nginx 找网络有没有资源 yum install nginx yum update 更新 反向代理 rpm # 红帽子包管理工具 rpm -i 安装 +vh rpm -e 移除 + vh rpm -vh 查看安装过程 rpm -qa 查询所有 搜索软件包 -rpm -e 移除 xargs 参数化 rpm -qa | grep jdk | xargs rmp -e 将grep 搜索到的结果 xargs(作为参数用来) 进行后面的操作 服务开机自启</description></item><item><title>02-options参数获取</title><link>http://lanms.github.io/docs/08-tornado/02-options%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/08-tornado/02-options%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/</guid><description>02-
options 参数获取 # tornado.options 经行全局的参数定义，转换，存储
tornado.options.define() # 参数 name 变量名,唯一性 default 设置选项变量的默认值 type 设置选项变量的类型,进行输入的值的转换， str int float 等 multiple 设置选项变量是否可以为多个值，默认为False help 选项变量的帮助体视信息 # 例如 tornado.options.define(name=&amp;#34;port&amp;#34;,default=8000,type=int) tornado.options.options 全局的options 对象，多有定义的选项变量都会成为其的属性 如 ： tornado.options.options.port
命令行获取参数 # tornado.options.parse_command_line() 获取命令行参数，转化为 tornado 的参数
# -*-coding: utf-8 -*- import tornado.web import tornado.ioloop # 引入 httpserver 模块 import tornado.httpserver import tornado.options # 定义 options 的变量的方法，定义参数 tornado.options.define(&amp;#39;port&amp;#39;, default=8000) class IndexHandler(tornado.</description></item><item><title>02-tf基础知识和模拟线性回归</title><link>http://lanms.github.io/docs/13-tensorflow/02-tf%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/13-tensorflow/02-tf%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</guid><description>TensorFlow # Tensor（张量）， 意味着N维数组，Flow（流）意味着基于数据流图的计算，TensorFlow即为张量从图的一端流动到另一端
支持 CNN（卷积神经网络）、RNN（循环神经网络）和 LSTM（长短期记忆网络）算法，
是目前在 Image,NLP最流行的深度学习神经网络模型
对比传统深度学习，为什么使用TensorFlow # 深度学习意味着建立具有很多层的大规模神经网络 除了输入 X，函数还使用一系列的参数，其中包括标量值、向量以及最昂贵的矩阵和高级张量 在训练网络之前，需要定义一个代价函数，常见的代价函数包括回归问题的方差以及分类时候的交叉熵 训练时，需要连续将多批新输入投入网络，对所有的参数求导后，代入代价函数，从而更新整个网络模型 这个过程中有两个主要问题： 较大的数字或者张量在一起相乘百万次的处理使整个模型代价非常大 手动求导耗时非常久 所以，TensorFlow 的对函数的自动求导和分布式计算，可以帮助我们节省很多时间。
TensorFlow优点 # 基于Python，写的很快并且具有高可读性 在多GPU系统上运行更为顺畅 代码编译效率较高 社区发展非常迅速并且很活跃 能够生成显示网络拓扑结构和性能的可视化图 原理 # TensorFlow是用数据流图（data flow graphs）技术来进行数值计算的 数据流图是描述有向图中数值计算过程 有向图中，节点通常代表数学运算，边表示节点之间的某种联系，它负责传输多为数据（Tensors） 节点可以被分配到多个计算设备上，可以异步合并地执行操作。因为是有向图，所以只有等到之前的节点们的计算状态完成后，当前节点才能执行操作 使用 # 使用（graph）来表示任务 在被称为会话（Session）的上下文（context）中执行图 使用 tensor 表示数据 通过变量（Variable） 维护状态 使用 feed 和 fetch 可以为任意操作（arbitray operation）赋值或者从中获取数据 实例：hello TensorFlow</description></item><item><title>02-函数-reduce()-map()-nonloca</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/02-%E5%87%BD%E6%95%B0-reduce-map-nonloca/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/02-%E5%87%BD%E6%95%B0-reduce-map-nonloca/</guid><description>介绍 # 主要讲述了一些函数的用法
reduce() map() nonlocal 1. reduce() # reduce 把一个函数作用在一个序列上, 这个函数必须接受两个参数, reduce 把结果和序列的写一个元素做累积计算 # 运用的是递归的思想 不同之处在于 它是将第一次调用函数的结果作为了第二次调用函数的第一个参数, reduce(f, [x1, x2, x3, x4, x5]) = f(f(f( f(x1, x2), x3),x4), x5) 2. map() # map() 得到的是一个 object 需要进行其他的实体化操作才能得需要的值 &amp;gt;&amp;gt;&amp;gt;def square(x) : # 计算平方数 ... return x ** 2 ... # 传入的是函数名 不带() &amp;gt;&amp;gt;&amp;gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 [1, 4, 9, 16, 25] # 传入的时候一个匿名函数 &amp;gt;&amp;gt;&amp;gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数 [1, 4, 9, 16, 25] # 提供了两个列表，对相同位置的列表数据进行相加, map 会自动查找需要是参数 &amp;gt;&amp;gt;&amp;gt; map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [3, 7, 11, 15, 19] 3.</description></item><item><title>02-建造者模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>建造者模式对比工厂模式 # 建造者模式对比工厂模式两者之间的差别并不明确，主要的区别在于工厂模式以单个步骤创建对象，而建造者模式以多个步骤创建对象，并且几乎始终会使用一个指挥者。另外一个区别是，在工厂模式中会立即返回一个创建好的对象，而在建造模式下，仅在需要客户端代码显示是才会请求指挥者返回最终的对象，可类比Django对数据库的操作
适用场景 # 想要创建一个复杂对象，对象由多个部分构成，且对象的创建要经过多个不同的步骤，这些步骤也许还需要遵从特定的顺序 要求一个对象能有不同的表现，并希望对象的构造与表现解耦 想要在某个时间点创建对象，但是在稍后的时间再做访问，延时生产 代码示例 https://github.com/lanms/Python_design_pattern/blob/master/02_builder_pattern/builder_pizza.py</description></item><item><title>03-docker-compose</title><link>http://lanms.github.io/docs/14-docker/03-docker-compose.yaml%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/14-docker/03-docker-compose.yaml%E9%85%8D%E7%BD%AE/</guid><description>docker compose 在 Docker 容器运用中具有很大的学习意义，docker compose 是一个整合发布应用的利器。而使用 docker compose 时，懂得如何编排 docker compose 配置文件是很重要的。
一. 前言 # 关于 docker compose 技术可以查看官方文档 Docker Compose
以下的内容是确立在已经下载好 Docker 以及 Docker Compose，可参看 Docker Compose 的官方安装教程 Install Docker Compose
二. Docker Compose 配置文件的构建参数说明
首先，官方提供了一个 yaml Docker Compose 配置文件的标准例子
version: &amp;ldquo;3&amp;rdquo; services:
redis: image: redis:alpine ports: - &amp;ldquo;6379&amp;rdquo; networks: - frontend deploy: replicas: 2 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure
db: image: postgres:9.4 volumes: - db-data:/var/lib/postgresql/data networks: - backend deploy: placement: constraints: [node.</description></item><item><title>03-Git团队开发</title><link>http://lanms.github.io/docs/03-git/03-git%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/03-git%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/</guid><description>03-Git团队开发
git clone 创建环境 当前分支 master 切换到自己的分支 ​ 测试环境1 自己的分支 15#环境
测试环境2 test 分支 16#环境
测试环境3 对外测试 test分支 83# 环境
线上环境1 分支 master
线上环境2 # 正式环境 共享数据库
git pull origin v3.0 本地获取 v3.0
微服务
docker
镜像 .iso 操作系统的文件（备份），里面有需要的环境
容器：操作系统
dockerfile : 启动的配置文件， 指定是哪个镜像，里面程序需要的环境</description></item><item><title>03-jenkins配置指南02</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/03-jenkins%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%9702/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/03-jenkins%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%9702/</guid><description>操作环境：Windows
一、环境准备
1 安装JDK
本文采用jdk-8u111-windows-x64.exe；
2 配置tomcat
本文采用tomcat8，无需安装，配置JAVA_HOME及JRE_HOME环境变量即可；
3 安装maven
本文采用maven3.3.9，无需安装；
4 安装Jenkins
下载地址https://jenkins.io/download/，仅下载war包，如下图：
将下载好的jenkins.war放进tomcat/webapps目录下。
二、相关配置
1 登入http://localhost:8080/jenkins，进入Jenkins初始化页面，第一次启动时间可能有点长，耐心等待。进入成功后会看到如下画面，按提示路径打开密码文件，输入密码：
解锁后又是一长段时间等待，此后可能出现如下图所示界面：
表示无法下载Jenkins插件，可能是因为防火墙导致，而Jenkins插件的安装非常重要，建议翻墙。如无法翻墙，则选择Skip Plugin Installations跳过插件安装。进入以下页面，设置登陆用户：
2 设置成功后即进入Jenkins主界面：
点击左上侧系统管理，进入Jenkins基本系统设置(主要是以下三块):
3 先进入“管理插件”模块安装必需的插件，以下是建议安装列表：
将本文附件中的插件放入Jenkins插件存放目录即可，如本文插件存放目录为：C:\Users\Administrator.jenkins\plugins（可点击系统管理–&amp;gt;系统设置,在最上方查看，如下图）；
4 配置系统设置
添加编码全局属性：
增加系统管理员邮件地址：
其他的可用默认配置，保存后退出。
5 添加全局配置Global ToolConfiguration
配置JDK，不采用自动安装：
配置maven，不采用自动安装：
以上即为需要设置的系统配置。
三、系统部署
系统设置完成后开始添加任务，任务类型选择自由风格：
创建完成后可在主页看到如下画面：
在”All” tab下能看到新建的任务，点击该任务，进入该任务的配置页面：
设置项目备注及构建规则：
配置项目轮询的源码位置(@HEAD表示构建最新的代码)并配置代码访问密码：
配置构建触发器，如下图配置为每天晚上9：30开始构建（Cron表达式）：
增加Invoke top-level Maven targets构建步骤，插件目标为编译、发现编译Bug、部署，另外还可以配置构建时忽略测试用例：
增加构建后操作步骤：Publish FindBugs analysis results，用于查看FindBugs插件的代码分析报告，该模块可采用默认配置：
增加构建后操作步骤：Deploy war/ear to a container，用于将构建后生成的war包部署至tomcat服务器，下图中Contextpath用于配置项目访问路径，如填/RMS_Server则表示项目的根访问目录为：http://localhost:8080/RMS_Server，Deploy on failure用于配置当前构建失败时是否仍然部署至tomcat，默认不选：
以上即为本项目的所有配置，完成后应用（或保存）并退出。
配置完成后即可开始构建，左侧可查看bugs分析信息及构建历史：
点击某个构建记录，如上图中的#31，即可查看构建日志、SVN代码提交日志及bugs分析结果：
四、编码问题
FindBugs分析报告中查看某些代码文件时可能出现中文乱码情况，如下图：
这是tomcat的编码问题导致的，可在系统管理中查看tomcat的相关编码情况：
主要关注的是file.encoding属性及sun.jnu.encoding属性，二者需要设置为UTF-8以兼容中文：
这可通过在tomcat配置文件/bin/catalina.bat文件中添加set “JAVA_OPTS=-Dfile.</description></item><item><title>03-stringIO</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/03-stringio/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/03-stringio/</guid><description> from io import StringIO s = StringIO() s.write(&amp;#39;www.baidu.com\n&amp;#39;) s.write(&amp;#39;abc\n&amp;#39;) s.write(&amp;#39;zhang&amp;#39;) o = s.getvalue() print(o) s.seek(0) # 指定开始读取的位置 while True: strBuf = s.readline() if not strBuf: break print(strBuf, end=&amp;#39;&amp;#39;) s.close() # 另外还有 readline() readlines() 等方法可以读取</description></item><item><title>03-vim文本编辑器</title><link>http://lanms.github.io/docs/05-linux/03-vim%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/03-vim%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</guid><description>vim 文本编辑器 基本操作笔记
1.启动和退出
vim + 文件名 打开或创建文件 :wq 末行模式 w 保存 q 退出 q! 强行退出 wq 保存退出 2.命令模式和编辑模式
i / a 进入编辑模式 Esc退出编辑模式 进入命令模式 : 末行模式 set nu 出现行号syntax on 开启语法高亮 (当时有效) vim .vimrc 文件修改设置 (永久有效) set nu syntax off ts=4 3.定标操作
G 去末尾 gg 回到开始 行号 + gg 光标移到某行 4.文本操作
复制代码 yy + 数字 多少行 粘贴 p dd 删除 + 数字 删除行 d$ 删除光标处到行位 删除单词 光标在第一个单词 dw Ctrl e 后一行 y前一行 f 前一页 b后一页 5.</description></item><item><title>03-原型模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>介绍 # 通过对传入的对象做深拷贝， 并且通过内部的更改对象属性的方法来使原始传入的对象的副本进行加工，最终在原始对象的原型的基础上得到新的对象
原型模式用于创建对象的完全副本，确切的说，创建一个对象的副本可以指代以下两件事
当创建一个浅副本时，副本依赖引用 当创建一个深副本时，副本复制所有的东西 第一种情况，我们关注提升应用性能和优化内存使用，在对象之间引入数据共享，单需要小心的修改数据，因为所有的改变对所有的副本都是可见的。
第二种情况中，我们希望能够对一个副本进行更改而不会影响其他对象。
代码示例https://github.com/lanms/Python_design_pattern/blob/master/03_prototype_pattern/prototype.py</description></item><item><title>03-基础指令</title><link>http://lanms.github.io/docs/13-tensorflow/03-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/13-tensorflow/03-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</guid><description>constant # 定义常量 a = tf.constant([1.0, 2.0], name=&amp;#34;a&amp;#34;) 关于张量 # 在 TensorFlow中，所有的数据都是通过张量的形式来表示。但是张量在 TensorFlow 中实现并不是直接采用数组的形式，它是对 TF 中运算结果的引用。在张量中并没有真正的保存数据，它保存的是如何得到数据的计算过程。
一个张量中主要保存了 name shape type 的三种属性
前向传播算法 #</description></item><item><title>03-请求核响应01</title><link>http://lanms.github.io/docs/08-tornado/03-%E8%AF%B7%E6%B1%82%E6%A0%B8%E5%93%8D%E5%BA%9401/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/08-tornado/03-%E8%AF%B7%E6%B1%82%E6%A0%B8%E5%93%8D%E5%BA%9401/</guid><description>03-请求核响应01</description></item><item><title>04-Git别名alias</title><link>http://lanms.github.io/docs/03-git/04-git%E5%88%AB%E5%90%8Dalias/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/04-git%E5%88%AB%E5%90%8Dalias/</guid><description>给Git设置alias别名 # 修改git的config文件，只是针对当前git仓库进行修改
[alias] st = status ck = checkout cl = clone br = branch mg = merge cm = commit cmd = commit --amend df = diff dft = difftool mt = mergetool last = log -1 HEAD cf = config line = log --oneline latest = for-each-ref --sort=-committerdate --format=&amp;#39;%(committerdate:short) %(refname:short) [%(committername)]&amp;#39; lg = log --pretty=format:\&amp;#34;%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green)[%cn]\&amp;#34; --decorate --date=short graph = log --pretty=format:\&amp;#34;%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\&amp;#34; --topo-order --graph --date=short type = cat-file -t dump = cat-file -p</description></item><item><title>04-pep8</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/04-pep8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/04-pep8/</guid><description/></item><item><title>04-redis安装配置</title><link>http://lanms.github.io/docs/05-linux/04-redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/04-redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid><description>非关系型数据库,redias安装,配置redias
redias 数据库 非关系型数据库
1.下载 # Linux 下载到的是源代码 yum install 2.构建安装 # 2.1 下载
进入解压后的目录 有目录Makfile 目录 构建 make 安装 make install (make &amp;amp;&amp;amp; make install) 2.2 改配置文件 redias.config
进入redias文件夹 复制 redias.config 更改 61行 bind: 原来绑定的是本机 改为的阿里云内网地址(末行模式 !ifconfig 查看inet)172.2(内网地址) 84行 为端口 默认设置是 6379, 可自己更改 :/require (搜索) 480行 去注释 改pass 密码: ***** ** 2.3 启动**
redis-server myredis.config &amp;gt; myredis.</description></item><item><title>04-网络编程-TCP-UDP-BS64</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp-udp-bs64/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp-udp-bs64/</guid><description>1. 网络介绍 # 多台独立自主的计算机互联的总称叫计算机网络 实现信息互联与资源共享 网络接口 &amp;ndash;&amp;gt; 网络 &amp;ndash;&amp;gt; 传输 &amp;ndash;&amp;gt; 应用 Inernet 因特网 基于TCP/IP Model 的网络 ​ 1. 1 TCP 可靠传输协议 # 传输控制协议 Transfer Control Protocol
可靠通信(数据不会穿丢也不会传错) 流量控制 自动调节发送数据的速度 拥塞控制 网络拥堵时会降低发送速率 可靠通讯的实现:
如何保证数据不会传输错误 握手机制 + 在数据中添加冗余校验对发送的数据 进行校验 流量控制:
滑动窗口机制 逐步增加发送的数据大小 拥塞控制:
减小滑动窗口 减小发送速率 1.2 UDP # User Datagram Protocol 用户数据宝协议 数据可能会丢失某部分内容 只要不影响使用 列如视屏 不会影响用户的使用 2.</description></item><item><title>04-适配器模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>介绍 # 适配器模式是一种结构型设计模式，帮助我们实现两个不兼容接口之间的兼容，实际就是将原来的对象转换为后者可以使用的对象
将不同的对象实例化，并且赋予同样的接口指向对象内部不同的方法，实现统一方法不同的返回的适配器效果
代码示例https://github.com/lanms/Python_design_pattern/blob/master/04-adapter.py</description></item><item><title>05-gitattributes设置文件属性</title><link>http://lanms.github.io/docs/03-git/05-gitattributes%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/05-gitattributes%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7/</guid><description>Git的gitattributes文件详解 # Git的gitattributes文件是一个文本文件，文件中的一行定义一个路径的若干个属性。
gitattributes文件以行为单位设置一个路径下所有文件的属性，格式如下： # 要匹配的文件模式 属性1 属性2 &amp;hellip; 在gitattributes文件的一行中，一个属性（以text属性为例）可能有4种状态： # 设置text 不设置-text 设置值text=string 未声明，通常不出现该属性即可；但是为了覆盖其他文件中的声明，也可以 !text gitattributes文件示例： # * text=auto .txt text .jpg -text .vcproj text eol=crlf .sh text eol=lf .py eol=lf 说明：
第1行，对任何文件，设置text=auto，表示文件的行尾自动转换。如果是文本文件，则在文件入Git库时，行尾自动转换为LF。如果已经在入Git库中的文件的行尾为CRLF，则该文件在入Git库时，不再转换为LF。
第2行，对于txt文件，标记为文本文件，并进行行尾规范化。
第3行，对于jpg文件，标记为非文本文件，不进行任何的行尾转换。
第4行，对于vcproj文件，标记为文本文件，在文件入Git库时进行规范化，即行尾为LF。但是在检出到工作目录时，行尾自动转换为CRLF。
第5行，对于sh文件，标记为文本文件，在文件入Git库时进行规范化，即行尾为LF。在检出到工作目录时，行尾也不会转换为CRLF（即保持LF）。
第6行，对于py文件，只针对工作目录中的文件，行尾为LF。
在一个Git库中可以有多个gitattributes文件： # 不同gitattributes文件中，属性设置的优先级(从高到低)：</description></item><item><title>05-Pycharm代码风格集成设置</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/05-pycharm%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E9%9B%86%E6%88%90%E8%AE%BE%E7%BD%AE/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/05-pycharm%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E9%9B%86%E6%88%90%E8%AE%BE%E7%BD%AE/</guid><description>设置代码分风格为 Google
设置默认的测试模式</description></item><item><title>05-yield函数</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/05-yield%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/05-yield%E5%87%BD%E6%95%B0/</guid><description>sys # 在Linux系统命令行参数 在输入命令是给的参数 sys.argv 接受所有的参数 保存在数组中 yield # # 生成式 列表已存在,占用空间大 list1 = [x for x in range(10)] #生成器 得到的是 generator 对象 引用 list3 = (x for c in range(10)) for i in list3: # 在需要用的时候再计算出值 print(i) # 生成器函数 def fibo(n): #普通函数 a, b = (0, 1) for _ in range(n): a, b = b, a + b return a def fibo(n): #生成器函数 保留上次计算的值 不会重复计算 a, b = (0, 1) for _ in range(n): a, b = b, a + b yield a string.</description></item><item><title>05-修饰器模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05-%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05-%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>修饰器模式 # 和继承相比，通常因该优先选择组合，因为继承使得代码更加难复用，继承关系是静态的。修时器模式能够以透明的方式动态的将功能添加到一个对象中，对该对象的功能进行扩展。
代码示例https://github.com/lanms/Python_design_pattern/blob/master/05-deactor_pattern.py</description></item><item><title>05-定时执行脚本任务</title><link>http://lanms.github.io/docs/05-linux/05-%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%BB%E5%8A%A1/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/05-%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%BB%E5%8A%A1/</guid><description>05-定时执行脚本任务
crontab -t 执行脚本 creotab -e 修改程序
今天做了个数据库的备份脚本，顺便系统得学习一下Linux下定时执行脚本的设置。Linux下的定时执行主要是使用crontab文件中加入定制计划来执行，设置比Windows稍微复杂一些(因为没有图形界面嘛)，但是也不是非常复杂，基本上用过一遍就能记住了，关键是要记住/var/spool/cron这个目录。下面看一下具体的用法： 首先查看一下/etc/crontab文件： $ cat /etc/crontab SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root HOME=/ # run-parts 01 * * * * root run-parts /etc/cron.hourly 02 4 * * * root run-parts /etc/cron.daily 22 4 * * 0 root run-parts /etc/cron.weekly 42 4 1 * * root run-parts /etc/cron.monthly 前四行是有关设置cron任务运行的环境变量。SHELL变量的值指定系统使用的SHELL环境(该样例为bash shell)，PATH变量定义了执行命令的路径。Cron的输出以电子邮件的形式发给MAILTO变量定义的用户名。如果MAILTO变量定义为空字符串(MAILTO=&amp;#34;&amp;#34;)，电子邮件不会被发送。执行命令或脚本时HOME变量可用来设置基目录。 文件/etc/crontab中每行任务的描述格式如下: minute hour day month dayofweek command minute - 从0到59的整数 hour - 从0到23的整数 day - 从1到31的整数 (必须是指定月份的有效日期) month - 从1到12的整数 (或如Jan或Feb简写的月份) dayofweek - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示) command - 需要执行的命令(可用as ls /proc &amp;gt;&amp;gt; /tmp/proc或 执行自定义脚本的命令) root表示以root用户身份来运行 run-parts表示后面跟着的是一个文件夹，要执行的是该文件夹下的所有脚本 对于以上各语句，星号(*)表示所有可用的值。例如*在指代month时表示每月执行(需要符合其他限制条件)该命令。 整数间的连字号(-)表示整数列，例如1-4意思是整数1,2,3,4 指定数值由逗号分开。如：3,4,6,8表示这四个指定整数。 符号“/”指定步进设置。“/&amp;lt;interger&amp;gt;”表示步进值。如0-59/2定义每两分钟执行一次。步进值也可用星号表示。如*/3用来运行每三个月份运行指定任务。 以“#”开头的为注释行,不会被执行。 如果一个cron任务需要定期而不是按小时,天,周,月来执行,则需要添加/etc/cron.</description></item><item><title>06-gitignore设置</title><link>http://lanms.github.io/docs/03-git/06-gitignore%E8%AE%BE%E7%BD%AE/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/06-gitignore%E8%AE%BE%E7%BD%AE/</guid><description>Git的gitignore文件设置 # [TOC]
在使用Git的过程中，我们喜欢有的文件比如日志，临时文件，编译的中间文件等不要提交到代码仓库，这时就要设置相应的忽略规则，来忽略这些文件的提交。
Git 忽略文件提交的方法 # 有三种方法可以实现忽略Git中不想提交的文件。
在Git项目中定义 .gitignore 文件 # 这种方式通过在项目的某个文件夹下定义 .gitignore 文件，在该文件中定义相应的忽略规则，来管理当前文件夹下的文件的Git提交行为。
.gitignore 文件是可以提交到公有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。
在 .gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如：
*.log *.temp /vendor 在Git项目的设置中指定排除文件 # 这种方式只是临时指定该项目的行为，需要编辑当前项目下的 .git/info/exclude 文件，然后将需要忽略提交的文件写入其中。
需要注意的是，这种方式指定的忽略文件的根目录是项目根目录。
定义Git全局的 .gitignore 文件 # 除了可以在项目中定义 .gitignore 文件外，还可以设置全局的 git .gitignore 文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。
这种方式也需要创建相应的 .gitignore 文件，可以放在任意位置。然后在使用以下命令配置Git：
git config --global core.excludesfile ~/.gitignore Git 忽略规则 # 详细的忽略规则可以参考官方英文文档
Git 忽略规则优先级 # 在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：
从命令行中读取可用的忽略规则 当前目录定义的规则 父级目录定义的规则，依次递推 $GIT_DIR/info/exclude 文件中定义的规则 core.</description></item><item><title>06-Linux操作命令</title><link>http://lanms.github.io/docs/05-linux/06-linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/06-linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</guid><description>Linux常用命令 # chmod a+x file.txt 赋予文件权限
echo 回声命令
printf 打印 可以格式化输出
cat 查看文档
rpm -q package_name 确认安装包已成功安装
sysctl -p 验证Linux 核心参数
$$ 当前的PID
$? 检测命令是否运行成功 -0 标准输入 -1 标准输出 -2 标准错误 -其他 错误
$* 运行的参数的个数
$@ 当前文件
$0 当前运行的文件
$1 第一个参数
read var 读取输入，赋值给 var
-d path 判断是否为目录 [ -d /home ] &amp;amp;&amp;amp; echo yes
pgrep xxx 获得xxx的进程ID
ps -ef |grep xxx 查看完成的进程信息
cat/proc/$PID/environ | tr '\0' '\n' 查看PID 进程的环境变量，替换 空 为换行输出</description></item><item><title>06-Pycharm集成检查工具</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/06-pycharm%E9%9B%86%E6%88%90%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/06-pycharm%E9%9B%86%E6%88%90%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</guid><description>pylint
Program: C:\Users\Administrator\AppData\Local\Programs\Python\Python36-32\Scripts\pylint.exe Arguments: -rn --msg-template=&amp;#34;{abspath}:{line}: [{msg_id}({symbol}), {obj}] {msg}&amp;#34; $FilePath$ Working directory: $FileDir$ Output filters: flake8
Program: $PyInterpreterDirectory$/python C:\Users\zhang\AppData\Local\Programs\Python\Python36\Scripts\flake8.exe Arguments: -m flake8 --show-source --statistics $ProjectFileDir$ Working directory: $ProjectFileDir$ Output filters: autopep8
Program: C:\Users\Administrator\AppData\Local\Programs\Python\Python36-32\Scripts\autopep8.exe Arguments: --in-place --aggressive --aggressive $FilePath$ Working directory: $ProjectFileDir$ Output filters: $FILE_PATH$\:$LINE$\:$COLUMN$\:.*</description></item><item><title>06-Python操作数据库</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/06-python%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/06-python%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>ORM - Object Relation Mapping 对象关系映射
关系型数据库 - 关系模型 Python 程序 - 对象模型 第三方框架 Alchemy 可以完成对象关系的双向转换,可以直接操作 数据库, 不用写 SQL 语句, 但是会降低性能 关键字 # host / [port] / user / passwd / db / charset / [autocommit / cursorclass=pymysql.cursors.DictCursor]
操作方法 # 调用的是pymysql的connect()/Cursor()方法 创建连接 pymysql.connect() 输入 import pymysql conn = pymysql.connect(host=&amp;#39;localhost&amp;#39;, port=3306,user=&amp;#39;root&amp;#39;, passwd=&amp;#39;123456&amp;#39;, db=&amp;#39;hrs&amp;#39;,charset=&amp;#39;utf8&amp;#39;, autocommit=False) 创建Cursor() cursor.execute() 执行sql语句 try: with conn.</description></item><item><title>06-外观模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式 # 系统会随着演化变得非常复杂，最终代码内部的类有大量的交互，错综复杂，不适合将其暴露给客户，外观设计模式有助于隐藏系统的内部复杂性，并通过一个简化的接口向客户端提供数据。本质上，外观模式是在已有的复杂系统上实现的一个抽象层。
外观模式常用于给一个复杂的系统提供简单的接口
核心实现方法是使用，抽象方法在类中实现固定接口，将其他没必要暴露在外的方法都交给类内部自己实现，在调用需要实现类中的功能的时候只需要将类中暴露出来的方法进行实现即可
代码示例https://github.com/lanms/Python_design_pattern/blob/master/06-face_pattern.py</description></item><item><title>07-Git_Flow使用方法</title><link>http://lanms.github.io/docs/03-git/07-git_flow%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/07-git_flow%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>http://www.berlinix.com/it/gitflow.php
http://www.berlinix.com/it/gitflow.php
http://www.berlinix.com/it/git.php
http://www.berlinix.com/it/git.php
gitflow分支管理模型 # gitflow的分支类型：
master分支（1个） develop分支（1个） feature分支。同时存在多个。 release分支。同一时间只有1个，生命周期很短，只是为了发布。 hotfix分支。同一时间只有1个。生命周期较短，用了修复bug或小粒度修改发布。 在这个模型中，master和develop都具有象征意义。master分支上的代码总是稳定的（stable build），随时可以发布出去。develop上的代码总是从feature上合并过来的，可以进行Nightly Builds，但不直接在develop上进行开发。当develop上的feature足够多以至于可以进行新版本的发布时，可以创建release分支。
release分支基于develop，进行很简单的修改后就被合并到master，并打上tag，表示可以发布了。紧接着release将被合并到develop；此时develop可能往前跑了一段，出现合并冲突，需要手工解决冲突后再次合并。这步完成后就删除release分支。
当从已发布版本中发现bug要修复时，就应用到hotfix分支了。hotfix基于master分支，完成bug修复或紧急修改后，要merge回master，打上一个新的tag，并merge回develop，删除hotfix分支。
由此可见release和hotfix的生命周期都较短，master/develop虽然总是存在但却不常使用。
以上就是gitflow的基本概念了。下面是nvie（gitflow的提出者，一个荷兰人！） A successful Git branching model（发布于2010年月5日）一文的笔记。
从右看起：
时间轴。 feature（玫红）。主要是自己玩了，差不多的时候要合并回develop去。从不与master交互。 develop（黄色）。主要是和feature以及release交互。 release（绿色）。总是基于develop，最后又合并回develop。当然对应的tag跑到master这边去了。 hotfix（红色）。总是基于master，并最后合并到master和develop。 master（蓝色）。没有什么东西，仅是一些关联的tag，因从不在master上开发。 接下来nvie说道自己喜爱git，因git改变了人们对合并/分支（merge/branches）的看法。从集中式的代码管理工具过来的人感到释放了（beware of merge conflicts, they bite you，注意合并冲突，它们会跳出来咬你！）。
gitflow实例 # 安装gitflow：
$ git clone --recursive git://github.com/nvie/gitflow.git $ cd gitflow/ $ sudo make install $ ls /usr/local/bin/git-flow /usr/local/bin/git-flow 到项目根目录下执行gitflow，因为之前修改没有commit，所以gitflow初始化失败：
$ git flow init fatal: Working tree contains unstaged changes.</description></item><item><title>07-Linux命令cat-find</title><link>http://lanms.github.io/docs/05-linux/07-linux%E5%91%BD%E4%BB%A4cat-find/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/07-linux%E5%91%BD%E4%BB%A4cat-find/</guid><description>常用命令 cat find
[TOC]
cat # -s 去除文件的多余空白行显示，不会对原文件进行修改 -n 显示行号 -t 挂起文件，始终显示最后更行内容 录制终端会话并进行回放
# 开始录制 script -t 2&amp;gt; timing.log -a output.seeeion # 回放 scriptreplay timing.log output.session find # -print 打印查找内容， \n 分隔
find . -type f -print|xargs ls -l
find . -iname 'filename' -print 模糊查找
逻辑运算关联查找 find . \( -name '*e*' -and -name 's*'\)
-a -and 关联查找 -o -or 逻辑或</description></item><item><title>07-pyline</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/07-pyline/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/07-pyline/</guid><description/></item><item><title>07-享元模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid><description>享元模式 # 介绍 # 享元模式通过为相似对象引入数据共享来最小化内存使用，提升性能，一个享元就是一个包含状态的独立的不可变数据的共享对象，依赖状态的可变数据不应是享元的一部分，因为每个对象的这种信息不相同，无法共享，如果享元需要非固有数据应该由客户端代码显示提供。
例如我们正在设计一个性能为关键的游戏，例如第一人称设计游戏（FPS），在FPS游戏中，玩家（士兵）共享一些状态，如外在的表现和行为。例如在 CS 游戏中，同一团队的所有士兵看起来都是一样的，所有的士兵都有一些共同 的动作，比如，低头，跳跃等，这意味着我们可以创建一个享元来包含所有的共同数据，当然，士兵也有许多因人而异的数据，这些数据不是享元的一部分，比如，枪支/健康状况和地理位置等。
应用场景 # 享元旨在优化性能和内存的使用。所有的嵌入式系统（如手机，平板，游戏终端和微控制器等）还有和性能相关的应用，如游戏，3D图形处理和实时系统等，都能从其中获益。
享元模式的使用条件：
应用需要使用大量的对象 对象太多，存储/渲染它们的代价太大，一旦移除对象中的可变形态，多组不同的对象可以被相对更少的共享对象所替代。 对象的ID对于应用不重要，对象共享改会造成ID的比较失败，所以不能依赖对象的ID。 关于memoization与享元模式之间的区别 # memoization是一种优化技术，使用一个缓存来避免重复计算已经在前期步骤中计算好的结果，memoization并不是只能应用于某种特定的编程方式，还可以应用于方法和简单的函数。享元则是一种特定于面向对象编程优化的审计模式，享元关注的是共享的诗句。
享元的实现 # 在Python中，享元可以以多种方式实现
代码示例https://github.com/lanms/Python_design_pattern/blob/master/07-share_pattern.py
def __new__(cls, tree_type): obj = cls.pool.get(tree_type, None) if not obj: obj = object.__new__(cls) cls.pool[tree_type] = obj obj.tree_type = tree_type return obj # pool 是一个类属性，使用 __new__ 把 Tree 变成一个元类，元类支持自引用，cls 引用的是 Tree 类， # 当客户端需要创建一个 Tree实例时，会以 Tree_type 参数传递树的种类， # 树的种类用于检查是否创建过相同的树，如果已经创建过，则返回之前创建的对象， # 否则，将这种新的树种添加到池中，并创建新的对象 一句话总结 # 享元模式就是通过避免重复创建大量的已有的实列来优化程序的结构和性能，Python中可以使用元类来创建，类似于单例模式</description></item><item><title>07-装饰器</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/07-%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/07-%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>装饰器
一个函数, 两个功能 def func_3(line): def comp(value): if value &amp;gt;= line: print(&amp;#39;{}&amp;gt;= {}&amp;#39;.format(value, line)) else: print(&amp;#39;{}&amp;lt; {}&amp;#39;.format(value, line)) return comp f = func_3(60) # 第一次调用外侧函数 f(89) # 第二次调用内层x # 相当于 func_3(60)(89) 自动将函数的参数放进了中间功能函数的中作为参数 会将实际传入目标函数的参数在装饰器中先传入进行验证, 也就是先执行装饰器的函数, 再执行目标函数 def dec_1(func): def wrapper(num1, num2): if num2 == 0: return (&amp;#39;0000&amp;#39;) return func(num1, num2) return wrapper def average_1(num1, num2): return num1 / num2 # averge_1 = dec_1(average_1) # a = averge_1(5, 0) # print(a) @dec_1 def sum_1(num1, num2): return num1 + num2 a = sum_1(1, 0) print(a) ==接收不同 的参数==</description></item><item><title>08-Centos7虚拟机扩展磁盘</title><link>http://lanms.github.io/docs/05-linux/08-centos7%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/08-centos7%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98/</guid><description>Centos虚拟机扩展磁盘
简介 # CentOS7虚拟机原硬盘空间只分配了10GB，需要扩容到20GB。 环境：VMware 10
VMware分配空间 # 选中虚拟机-&amp;gt;虚拟机设置-&amp;gt;硬盘-&amp;gt;实用工具-&amp;gt;扩展-&amp;gt;设置最大磁盘大小-&amp;gt;点击扩展 CentOS7内部分配 # 可以参考：http://jingyan.baidu.com/article/54b6b9c0fc8b0b2d583b47c6.html
查看当前磁盘空间，/dev/mapper/cl-root硬盘空间只有8GB，打算扩容： # df -h Filesystem Size Used Avail Use% Mounted on /dev/mapper/cl-root 8.0G 3.8G 4.3G 47% / devtmpfs 482M 0 482M 0% /dev tmpfs 493M 0 493M 0% /dev/shm tmpfs 493M 6.7M 486M 2% /run tmpfs 493M 0 493M 0% /sys/fs/cgroup /dev/sda1 1014M 184M 831M 19% /boot tmpfs 99M 0 99M 0% /run/user/0 对新增的硬盘空间做新增分区（硬盘数没有增加，增加的是空间） # fdisk /dev/sda Welcome to fdisk (util-linux 2.</description></item><item><title>08-MVC模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08-mvc%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08-mvc%E6%A8%A1%E5%BC%8F/</guid><description>MVC模式 # 模型-视图-控制器模式
SoC 关注点分离（Separation of Concerns）是软件工程相关设计原则之一。SoC原则背后的思想是将一个应用切分成不同的部分，每个部分解决一个单独的关注点。分层设计中的层次即是关注点的例子，使用SoC原则能简化软件应用的开发和维护。
MVC就是应用到面向对象编程的SoC原则。
模型是核心部分，代表着应用的信息本源，包含和管理业务逻辑，数据，状态以及应用的规则。
视图是模型的可视化表现。
控制器是模型和视图之间的链接。模型和视图之间的信息交互都是由控制器进行控制。
总结 # MVC模式将各个模块的功能进行解耦和，方便应用的管理和代码的扩展</description></item><item><title>08-tox使用</title><link>http://lanms.github.io/docs/03-git/08-tox%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/08-tox%E4%BD%BF%E7%94%A8/</guid><description>tox
tox是通用的虚拟环境管理和测试命令行工具，tox能够让我们在同一个Host上自定义出多套相互独立且隔离的python环境
检查软件包能否在不同的python版本或解释器下正常安装 在不同的环境中运行测试代码 作为持续集成服务的前端，大大减少测试工作所需的时间 2、openstack社区tox使用：
比如openstack社区的openstack-infra/project-config工程，其gerrit配置的门禁，其门禁具体执行中使用了tox执行基本语法检测。
S1、clone该工程：
git clone https://github.com/openstack-infra/project-config.git
S2、查看project-config的工程门禁配置（project-config/zuul/layout.yaml截取一部分）：
- name: openstack-infra/project-config template: - name: bindep-fallback - name: merge-check check: - gate-project-config-gerrit - gate-project-config-grafyaml - gate-project-config-layout # check阶段的门禁 - gate-project-config-linters-ubuntu-xenial - gate-project-config-irc-access - gate-project-config-jenkins-project - gate-project-config-nodepool - gate-infra-docs-index - gate-generate-specs-site - gate-project-config-dib S3、查看gate-project-config-layout的工程配置：
（位于project-config/jenkins/jobs/infra.yaml中）
job: name: gate-project-config-layout node: ubuntu-trusty builders: - net-info # 显示环境信息，如构建时间、ip、网络状况等 - zuul-git-prep # zuul-clone工程 - install-distro-packages # 安装相应依赖 - revoke-sudo # 取消sudo权限 - run-tox: # 调用tox的相关脚本 envlist: &amp;#39;zuul&amp;#39; publishers: - test-results - console-log S4、重点是查看builder：run-tox的配置，位于project-config/jenkins/jobs/macros.</description></item><item><title>08-tox集成使用指南</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/08-tox%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/08-tox%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid><description>以keystone工程为例，其他工程类似
内容包括：打源码包（sdist）、单元测试（UT）、测试覆盖率（coverage）、代码格式检查（pep8，flake）
pip install tox 可以将tox安装在外部全局环境中，方便每次使用tox命令，而不用激活虚拟环境，tox会在当前工程的文件目录下创建.tox文件目录来下载需要的虚拟环境和存放生成的文件
1、引子 # 接触了一段时间openstack社区，并提交了几个bug之后，就发现社区中，从bug提交、问题确认、到bug修复，代码review，自动构建、单元测试、静态检查、再到代码合入，也就是我们经常说的持续集成（CI），是一个非常简单和高效的过程。
开发人员都是懒人，这点我从来都没有怀疑过，怎么让一群懒人（还是一大群）将CI的这么多步骤做规范，并且不觉得是一个麻烦的过程，需要很高的技巧和聪明才智。
我认为持续集成（CI）有两个重点需要把握，首先要好上手，简单易学，开发都是懒人，不好用的东西，很难养成习惯使用；其次做且仅做应该做的事，也就是CI检查的范围要确定，保持CI的高速，写完代码10分钟之内，要出ut和coverage的结果。
来让我们看看openstack社区的持续集成都包括哪些内容，使用了哪些工具。
2、tox具体使用方法 # 对openstack几个核心工程代码比较熟悉的朋友，可能都会注意到代码根目录下都有个tox.ini文件，tox其实就是openstack持续集成中非常重要的一个工具，tox.ini就是tox的配置文件。
tox的官方对于tox的定义是这样的：
Tox as is a generic virtualenv management and test command line tool
http://tox.readthedocs.org/en/latest/
也就是一个通用的虚拟环境管理和测试命令行工具。
所谓的虚拟环境，就是可以在一个主机上，自定义出多套的python环境，多套环境中使用不同的python拦截器，环境变量设置，第三方依赖包，执行不同的测试命令，最重要的是各个环境之间互不影响，相互隔离。
最典型的应用就测试在不同python版本下代码的兼容性，我们可以为py2.4，py2.5，py2.6，py2.7创建不同的虚拟环境，都可以用tox统一管理；也可以在tox.ini中自定义虚拟环境，例如：testevn:pep8，代码格式检查；testenv:cover，测试覆盖率。
我们以最新的H版的keystone的tox.ini为例：
首先定义tox的全局配置，列出了需要执行的虚拟环境列表，在命令行中直接执行tox，就会依次执行py26，py27，pep8
[tox] envlist = py26,py27,pep8 然后定义了虚拟环境的配置
setenv列出了虚拟机环境中生效的环境变量，一些配色方案和单元测试标志；
deps列出了虚拟环境需要的第三方依赖包，也就是keystone根目录下的requirements.txt和test-requirements.txt其中包括了keystone运行和单元测试时，需要用到的依赖包，每个虚拟环境创建的时候，会通过pip install -r requirements.txt和pip install -r test-requirements.txt安装依赖包到虚拟环境；
commands就是在当前虚拟环境中需要执行的命令，python tools/patch_tox_venv.py就是安装了redhat-eventlet.patch补丁；nosetests {posargs}就是执行nose进行单元测试，{posargs}参数就是可以将tox的参数传递给nosetests，例如：tox &amp;ndash; &amp;ndash;with-coverage执行的时候就是nosetests &amp;ndash;with-coverage
[testenv] setenv = VIRTUAL_ENV={envdir} NOSE_WITH_OPENSTACK=1 NOSE_OPENSTACK_COLOR=1 NOSE_OPENSTACK_RED=0.05 NOSE_OPENSTACK_YELLOW=0.025 NOSE_OPENSTACK_SHOW_ELAPSED=1 NOSE_OPENSTACK_STDOUT=1 deps = -r{toxinidir}/requirements.</description></item><item><title>08-递归函数</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/08-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/08-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</guid><description>简介 # ​ 一个递归函数的调用过程类似于多个函数的嵌套的调用，只不过调用函数和被调用函数是同一个函数。为了保证递归函数的正确执行，系统需设立一个工作栈。具体地说，递归调用的内部执行过程如下：
运动开始时，首先为递归调用建立一个工作栈，其结构包括值参、局部变量和返回地址； 每次执行递归调用之前，把递归函数的值参和局部变量的当前值以及调用后的返回地址压栈； 每次递归调用结束后，将栈顶元素出栈，使相应的值参和局部变量恢复为调用前的值，然后转向返回地址指定的位置继续执行。 简单来说:
递归就是对函数自身的调用, 但是必须有一个明确的结束条件, 称为递归出口 简单的递归函数
def foo(n): if n == 1: # 最后写中间的条件部分 return 1 return n * foo( n - 1 ) # 优先写递归调用的函数 ===&amp;gt; fact(5) ===&amp;gt; 5 * fact(4) ===&amp;gt; 5 * (4 * fact(3)) ===&amp;gt; 5 * (4 * (3 * fact(2))) ===&amp;gt; 5 * (4 * (3 * (2 * fact(1)))) ===&amp;gt; 5 * (4 * (3 * (2 * 1))) ===&amp;gt; 5 * (4 * (3 * 2)) ===&amp;gt; 5 * (4 * 6) ===&amp;gt; 5 * 24 ===&amp;gt; 120 代码来源, 廖雪峰的官方博客</description></item><item><title>09-alias编辑系统命令</title><link>http://lanms.github.io/docs/05-linux/09-alias%E7%BC%96%E8%BE%91%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/09-alias%E7%BC%96%E8%BE%91%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</guid><description>vi ~/.bashrc 添加别名 在profile中设置PATH
vi /etc/profile
找到export行，在下面新增加一行，内容为：
export PATH=$PATH:/usr/local/apache/bin export PATH=$PATH:/home/lanms/Desktop/software/navicat121_premium_cs_x64 export PATH=$PATH:/usr/local/apache/bin 后面为想要添加的服务所在的文件目录 注：＝ 等号两边不能有任何空格。这种方法最好,除非手动强制修改PATH的值,否则将不会被改变。 编辑/etc/profile后PATH的修改不会立马生效，如果需要立即生效的话，可以执行
source profile命令苏</description></item><item><title>09-git_rebase</title><link>http://lanms.github.io/docs/03-git/09-git_rebase/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/09-git_rebase/</guid><description>参考链接
https://www.jianshu.com/p/4a8f4af4e803</description></item><item><title>09-unittest</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/09-unittest/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/09-unittest/</guid><description/></item><item><title>09-代理模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式 # 在某些应用中我们想要访问一个或者多个重要的操作，有时会进行一些敏感操作，在允许用户进行这些敏感操作的之前，我们希望确保用户具备足够的权限，操作系统也存在这样的情况，如在执行某些操作的时候必须有管理员权限才可以进行。
常见的知名代理模式 # 远程代理：实际存在于不同地址空间的对象在本地的代理 虚拟代理：用于懒初始化，将一个大计算量对象的创建延迟到真正需要的时候 保护/防护代理：控制对敏感对象的访问 智能（引用）代理：在对象被访问时执行额外的动作，此类代理的例子包括引用计数和线程安全检查。 虚拟代理，代码示例https://github.com/lanms/Python_design_pattern/blob/master/09-proxy_pattern/09-1-Lazy.py
代理模式代码 https://github.com/lanms/Python_design_pattern/blob/master/09-proxy_pattern/09-2-proxy.py</description></item><item><title>09-线程和进程</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/09-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/09-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</guid><description>线程和进程 # 1. 同步和异步 # 针对结果
同步 - 多任务，多个任务执行的时候有先后的顺序， 必须一个先执行后， 另外一个才能继续执行， 只有一条运行主线 异步 - 多任务， 多个任务之间执行没有想先后顺序， 可以同时运行， 执行时先后顺序不会对程序有什么影响， 存在多条运行主线 2. 阻塞和非阻塞 # 针对运行状态 线程的状态（就绪、运行、阻塞）
阻塞 - 从调用者的角度出发， 如果在调用的时候， 被卡住， 不能再继续往下执行， 需要等待， 就是 阻塞 非阻塞 - 从调用者的角度出发， 如果在调用的时候， 没有被卡住， 能够继续向下执行， 无需等待， 就是 非阻塞 3. 并发和并行 # 并发 - 同时处理任务 并行 - 交替处理任务， 类似线程之间不断切换 并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力,强调的是同时.
下面这篇文章可以参考解释上述概念
https://blog.csdn.net/timemachine119/article/details/54091323
进程和线程使用 # 进程：内存独立， 线程共享同一进程的内存， 一个进程就像是一个应用程序（app） 进程是资源的组合， 线程是执行的单位 进程之间不能直接相互访问， 同一进程中的线程可以相互通讯 创建新的进程很消耗系统资源， 线程非常轻量， 只需要保存线程运行时的必要数据， 如上下文， 程序的堆栈信息 同一进程里的线程可以相互控制， 父进程可以控制子进程 开多进程</description></item><item><title>10-git_rebase</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/10-git_rebase/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/10-git_rebase/</guid><description>https://www.jianshu.com/p/4a8f4af4e803
pick：保留该commit（缩写:p） reword：保留该commit，但我需要修改该commit的注释（缩写:r） edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） squash：将该commit和前一个commit合并（缩写:s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） exec：执行shell命令（缩写:x） drop：我要丢弃该commit（缩写:d） s: 提供可编辑界面，编辑commit
f: 自动融合，放弃当前的commit内容
r: 需要继续　git rebase &amp;ndash;continue 进行编辑commit
e: 需要继续执行命令　git commit &amp;ndash;admend 修改commit
d: 删除commit ,慎用！
p: 保留commit
x: 执行cmd shell 命令</description></item><item><title>10-Linux安装工具命令</title><link>http://lanms.github.io/docs/05-linux/10-linux%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/10-linux%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/</guid><description>修改Host文件
sudo gedit /etc/hosts chorme
sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ &amp;amp; wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - &amp;amp;sudo apt-get update &amp;amp; sudo apt-get install google-chrome-stable &amp;amp; /usr/bin/google-chrome-stable fish
软件源所在文件目录
/etc/apt/sources.list.d apt update apt install fish sublime
http://www.sublimetext.com/docs/3/linux_repositories.html
wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add - echo -e &amp;#34;\n[sublime-text]\nServer = https://download.sublimetext.com/arch/dev/x86_64&amp;#34; | sudo tee -a /etc/pacman.conf apt-get update apt-get install sublime-text # 启动 subl # 修改host 添加 127.</description></item><item><title>10-ubantu安装工具命令</title><link>http://lanms.github.io/docs/05-linux/10-ubantu%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/05-linux/10-ubantu%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/</guid><description>将vim设置为默认文本编辑器
echo export EDITOR=/usr/bin/vim &amp;gt;&amp;gt; ~/.bashrc 修改Host文件
sudo gedit /etc/hosts chorme
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome-stable_current_amd64.deb fish
软件源所在文件目录
/etc/apt/sources.list.d apt update apt install fish sublime
http://www.sublimetext.com/docs/3/linux_repositories.html
wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add - echo -e &amp;#34;\n[sublime-text]\nServer = https://download.sublimetext.com/arch/dev/x86_64&amp;#34; | sudo tee -a /etc/pacman.conf apt-get update apt-get install sublime-text # 启动 subl # 修改host 添加 127.0.0.1 license.sublimehq.com 127.0.0.1 45.55.255.55 127.0.0.1 45.55.41.223 # 注册码 ----- BEGIN LICENSE ----- sgbteam Single User License EA7E-1153259 8891CBB9 F1513E4F 1A3405C1 A865D53F 115F202E 7B91AB2D 0D2A40ED 352B269B 76E84F0B CD69BFC7 59F2DFEF E267328F 215652A3 E88F9D8F 4C38E3BA 5B2DAAE4 969624E7 DC9CD4D5 717FB40C 1B9738CF 20B3C4F1 E917B5B3 87C38D9C ACCE7DD8 5F7EF854 86B9743C FADC04AA FB0DA5C0 F913BE58 42FEA319 F954EFDD AE881E0B ------ END LICENSE ------ mysql</description></item><item><title>10-协程和aiohttp</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/10-%E5%8D%8F%E7%A8%8B%E5%92%8Caiohttp/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/10-%E5%8D%8F%E7%A8%8B%E5%92%8Caiohttp/</guid><description>关于 GIL # Pyhton的全局解释器锁 协程 # 协程其实就是一个线程， 在执行过程中， 在程序内部中断，然后转而执行别的程序，在适当的时候再返回来接着执行 优势 # 最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 原因 : # cpython解释器中存在一个GIL(全局解释器锁),他的作用就是保证同一时刻只有一个线程可以执行代码, 因此造成了我们使用多线程的时候无法实现并行。 解决方案法 : # 更换解释器 比如使用jpython(java实现的python解释器)
使用多进程完成多任务的处理
Python语言和GIL没有关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
GIL：
全局解释器锁。
每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后, 必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100 Python使用多进程是可以利用多核的CPU资源的。 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁 结论:
在 处理像科学计算 这类需要持续使用cpu的任务的时候 单线程会比多线程快 在 处理像IO操作等可能引起阻塞的这类任务的时候 多线程会比单线程 yield函数 # 生成器函数， 可以理解为暂停，程序会暂停在yield的地方， 等待下一次调用 next() 时， 程序又会执行一次， 然后继续执行 可以通过打断点来进行理解， 让程序一步一步执行， 查看程序到底执行到了那里， 暂停到了那里</description></item><item><title>10-责任链模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid><description>责任链模式 # 当在开发中无法预知使用哪种方法处理某个特定的请求时，使用责任链模式来不停的进行吹，直到有合适的处理方法为止
原则：
存在一个对象链 我们一开始将请求发送给链中的第一个对象 对象决定是否要处理该请求 将请求传递给下一个对象 重复该过程，一直到链尾 code https://github.com/lanms/Python_design_pattern/blob/master/10_chain_pattern.py</description></item><item><title>11-元类</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/11-%E5%85%83%E7%B1%BB/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/11-%E5%85%83%E7%B1%BB/</guid><description>元类介绍 # type可以直接生成类（class），但也可以先生成元类（metaclass），再使用元类批量定制类（class）
使用 class 创建类
class Hello(): def say(self, name=&amp;#39;world&amp;#39;): print(&amp;#39;Hello, %s&amp;#39; % name) h = Hello() h.say() 使用 type 直接创建
def say(self, name=&amp;#39;world&amp;#39;): print(&amp;#34;Hello, %s&amp;#34; % name) Hello = type(&amp;#39;Hello&amp;#39;, (object, ), dict(say_hello=say)) h = Hello() h.say() 先生成元类 metaclass，再批量创建
# 传入type class SayMetaClass(type): # 传入 类名称、父类、属性 def __new__(cls, name, bases, attrs): # 添加属性 attrs[&amp;#39;say_&amp;#39;+name] = lambda self,value,saying=name: print(saying+&amp;#39;,&amp;#39;+value+&amp;#39;!</description></item><item><title>11-命令模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid><description>命令模式 # 只需要执行一个命令，就可以实现对应的功能 调用命令的对象知道如何执行命令的对象解耦，调用者无需知道命令的任何实现细节 如果有意义，可以把多个命令组织起来，这样调用者能够按照顺序执行它们 code https://github.com/lanms/Python_design_pattern/blob/master/11_command_pattern.py</description></item><item><title>12-Anaconda创建虚拟环境</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/12-anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/12-anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid><description>下载安装 # https://www.jianshu.com/p/920a6e18cfd6 (参考文档)
下载地址： https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/ 下载最新的windows版本
安装过程如果没有选择添加环境变量，那么需要手动添加一下环境变量
常用命令 # conda -V (大写) 查看版本
conda list 查看安装了哪些包
conda env list 或 conda info -e 查看当前存在哪些虚拟环境
conda update conda 检查更新当前的conda
创建Python虚拟环境 # conda create -n your_env_name python=X.X(版本) 创建指定Python版本的虚拟环境
激活 activate your_env_name
对指定虚拟环境安装扩展包 # conda install -n your_env_name [package_name]
卸载指定的安装包 # conda remove -n your_env_name &amp;ndash;all 全部卸载
conda remove &amp;ndash;name your_env_name [package_name] 卸载某个包</description></item><item><title>12-解释器模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>解释器模式 # 客户分类：
基本用户 高级用户 解释器模式主要是引起应用的高级用户的兴趣
code https://github.com/lanms/Python_design_pattern/blob/master/12_interpreter_pattern.py</description></item><item><title>13-py2和py3的区别</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/13-py2%E5%92%8Cpy3%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/13-py2%E5%92%8Cpy3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>python3和python2的区别 # 注：没有特别说明的都是 python3 的特性
性能 # 2的性能比3的性能高越 15%-30%
编码 # 3使用的是 utf-8
语法 # 去除了&amp;lt;&amp;gt; 全部使用 ！=
全部改用 repr() 去除 ``
加入关键子 as和with, 还有True,False None
整型相除得到的是浮点数， // 得到的是整型
加入 nolocal
将print关键子去除，添加 print() 方法
print &amp;ldquo;This is&amp;rdquo;, 2*2 print &amp;raquo; sys.stderr. &amp;lsquo;fatal error&amp;rsquo; 3.X print(&amp;ldquo;fatal error&amp;rdquo;, file=sys.stderr) x &amp;lt; y 当 x 和 y 的类型不匹配抛出 Typeerror 而不是随机的 bool 值
输入函数改变
2 ： raw_input(&amp;ldquo;请输入：&amp;rdquo;) 3 ： input(&amp;ldquo;请输入：&amp;rdquo;) 不能定义函数如下</description></item><item><title>13-观察者模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>观察者模式 # 在一个对象的状态改变时可以改变另外一组对象
观察者模式描述单个对象与一个或多个对象之间的发布订阅关系。在MVC的例子中，发布者是模型，订阅者是视图。
观察者模式希望一个对象的状态变化时，能够通知/提醒多有相关者，则可以使用观察者模式，观察者模式的一个重要特性为，在运行时，订阅者/观察者的数量以及观察者时谁都会发生变化。
code https://github.com/lanms/Python_design_pattern/blob/master/13_observer_pattern.py</description></item><item><title>14-函数的用法汇总</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/14-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/14-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/</guid><description>or
取第一个不为空值的变量
a = b or c or d or e callable
验证函数是否是可被调用的方法
&amp;gt;&amp;gt;&amp;gt; callable(max) True &amp;gt;&amp;gt;&amp;gt; callable(9) False</description></item><item><title>14-状态模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid><description>状态模式 #</description></item><item><title>15-python内置函数库</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/15-python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BA%93/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/15-python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BA%93/</guid><description>1. functool # 1.1 lru_cache # 当api传入相同参数时，快速返回缓存的值 from urllib import request, error from functools import lru_cache @lru_cache(maxsize=32) def get_pep(num): resource = &amp;#39;http://www.python.org/dev/peps/pep-%04d/&amp;#39; % num try: with request.urlopen(resource) as s: return s.read() except error.HTTPError: return &amp;#34;NOT found {}&amp;#34;.format(num) for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991: pep = get_pep(n) print(f&amp;#34;{n}{len(pep)}{pep}&amp;#34;) 1.</description></item><item><title>15-策略模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid><description/></item><item><title>16-模板模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</guid><description/></item><item><title>Celery和RabbitMQ</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/celery%E5%92%8Crabbitmq/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/celery%E5%92%8Crabbitmq/</guid><description>Celery和RabbitMQ
Celery是Distributed Task Queue，分布式任务队列，分布式决定了可以有多个 worker 的存在，队列表示其是异步操作，即存在一个产生任务提出需求的 master，和很多的等待分配的 工人
在 Python 中定义Celery，引入了 Broker 中间件，当 worker 处理完之后还会有一个 backend
任务模块 Task
包含异步任务和定时任务，其中，异步任务通常在业务逻辑中被触发并投放在任务队列中，而定时任务也会有 Celery Beat 进程周期性地将任务发往任务队列
消息中间件 Broker
任务调度队列，官方推荐使用 RabbitMQ和Redis等
任务执行单元 Worker
监控消息队列，获取队列中调度的任务，并执行它
任务结果 Backend
存储任务处理的结果，存储也可以使用RabbitMQ，Redis, MongoDB
# 安装 RabbitMQ sudo apt-get install rabbitmq-server # 启动 sudo rabbitmq-server -detached # 停止 sudo ranbbitmqctl stop # 设置 RabbitMQ sudo rabbitmqctl add_user USER_NAME PASSWORD #创建用户 sudo rabbitmqctl add_vhost VHOST_NAME # 添加 vhost 的名称 sudo rabbitmqctl set_user_tags USER_NAME USER_TAGS_NAME # 添加tags sudo rabbitmqctl set_permissions VHOST_NAME USER_NAME &amp;#39;.</description></item><item><title>celery的使用</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/celery%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/celery%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>celery的使用
https://blog.csdn.net/Shyllin/article/details/80940643
https://www.cnblogs.com/forward-wang/p/5970806.html
启动命令
celery -A task_dir_name beat
http://127.0.0.1:5555/user/celery/?v1=aaaa&amp;amp;v2=bbb 可使用 AWS 的 SQS 和 DynmoDB
windows
pip install eventlet celery -A &amp;lt;mymodule&amp;gt; worker -l info -P eventlet http://www.cnblogs.com/cwp-bg/p/8759638.html
celery_aaa
celery -A celery_aaa worker --loglevel=info python3 -m celery_aaa.run_tasks 可视化 celery 和 rabbitmq
pip install flower 所有的任务会存在本地的 schedule文件中
当没有发布任务时 worker 会等待，直到有任务发布
当没有worker存在时，会一直发布任务，直到worker出现
启动任务发布时会返回它的pid，可以通过kill pid 来停止
celery_aaa
# 运行worker celery -A celery_aaa worker --loglevel=info # 导入任务 from celery_util.celery_aaa.tasks import longtime_add longtime_add.</description></item><item><title>Docker使用</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/docker%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/docker%E4%BD%BF%E7%94%A8/</guid><description>Docker使用
安装
https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce-1
命令
https://www.jianshu.com/p/ef8f17442d8f</description></item><item><title>emacs配置</title><link>http://lanms.github.io/docs/17-emacs/emacs%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/17-emacs/emacs%E9%85%8D%E7%BD%AE/</guid><description>evil 为emacs绑定vim键
git clone https://github.com/emacs-evil/evil ~/.emacs.d/evil 编辑~/.emacs
(add-to-list &amp;#39;load-path &amp;#34;~/.emacs.d/evil&amp;#34;) (require &amp;#39;evil) (evil-mode 1) siderbar</description></item><item><title>jsonp跨域请求的处理</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/jsonp%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/jsonp%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/</guid><description/></item><item><title>js中cookie值的设置和获取</title><link>http://lanms.github.io/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/js%E4%B8%ADcookie%E5%80%BC%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/js%E4%B8%ADcookie%E5%80%BC%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96/</guid><description>JS cookie的取值和设置值 # 第一步：引入js
&amp;lt;script src=&amp;quot;/XX/js/login/jquery-1.5.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;/XX/js/login/jquery.cookie.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; 第二步：存放值
$.cookie('the_cookie', 'the_value', { expires: 7, path: '/' }); 一步写到位，不要轻易把path去掉。不然只能在当前js使用，我吃过亏的
举个实例吧： 需求：城市定位，需要下次进入页面时记住上次自动定位的城市名字或者手动选择的城市名字
百度地图API功能
var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function(r){ if(this.getStatus() == BMAP_STATUS_SUCCESS){ var 城市名= r.address.city；（拿到的城市名字） //往cookie里面放城市名称 $.cookie(&amp;#39;locateCity&amp;#39;, 城市名, { expires: 7 ,path:&amp;#39;/&amp;#39;}); } else { //alert(&amp;#39;failed&amp;#39;+this.getStatus()); mui.alert(&amp;#34;城市定位失败&amp;#34;); } },{enableHighAccuracy: true}) 第三步：取值
var locateCity = $.cookie(&amp;#39;locateCity&amp;#39;);</description></item><item><title>memcached的安装和启动</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/memcached%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/memcached%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8/</guid><description>README
windows创建服务 # schtasks /create /sc onstart /tn memcached /tr &amp;#34;&amp;#39;D:\softWare\memcached-amd64\memcached.exe&amp;#39; -m 512 -p 10000 &amp;#34; 删除服务
schtasks /delete /tn memcached windows启动服务
memcached -u root -l 0.0.0.0 -p 10001 -c 1024 -P D:\softWare\memcached-amd64\Pid\memcached.pid 启动memcached # memcached -d -m 10 -u root -l 0.0.0.0 -p 12000 -c 256 -P /tmp/memcached.pid 参数说明: -d 是启动一个守护进程 -m 是分配给Memcache使用的内存数量，单位是MB -u 是运行Memcache的用户 -l 是监听的服务器IP地址 -p 是设置Memcache监听的端口,最好是1024以上的端口 -c 选项是最大运行的并发连接数，默认是1024，按照你服务器的负载量来设定 -P 是设置保存Memcache的pid文件 常用命令</description></item><item><title>MySQL主从分离</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/</guid><description>MySQL主从分离，读写分离
Orical适合做集群，没有主从
磁盘阵列，raid
数据库日志 # 错误日志，数据日志，慢查询日志，启动日志
数据日志
全量备份：全部备份，每周 增量备份：每天，将增加的部分进行备份，日志中会记录每个对数据库的操作记录， 冷备份：关掉数据库备份 热备份：不关数据库备份 主从分离配置 # # master配置 server-id=200 # 一般取IP的最后一组数字 innodb_flush_log_at_trx_commit=2 sync_binlog=1 log-bin=mysql-bin-200 binlog-do-db= # 同步的数据库的名称,全部可以使用 * 重启MySQL # 客户端执行命令,授权给 slave grant replication slave on *.* to &amp;#39;zhang&amp;#39;@&amp;#34;IP&amp;#34; identified by &amp;#39;123456&amp;#39;; show master status; # slave 更改配置 server-id=201 innodb_flush_log_at_trx_commit=2 sync_binlog=1 log-bin=mysql-bin-201 # slave mysql客户端执行命令 change master to master_host=&amp;#39;10.7.152.77&amp;#39;, # 连接 master的 IP master_user=&amp;#39;zhang&amp;#39;, # master授权的用户 master_password=&amp;#39;123456&amp;#39;, # 密码 master_log_file=&amp;#39;mysql-bin-200.</description></item><item><title>MySQL优化</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%BC%98%E5%8C%96/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%BC%98%E5%8C%96/</guid><description>MySQL优化 # SQL优化 参数配置优化 对sql语句进行优化 # 缓存查询语句：
不开启缓存的情况：cursor.execute(&amp;quot;select username from user where singup_data&amp;gt;=curdate()&amp;quot;); 开启缓存进行查询：cursor.execute(&amp;quot;select * from user where signup_data&amp;gt;=%s&amp;quot;, (datetime.now()))但是有时会有 sql 注入攻击的风险 EXPLAIN：对要执行的 sql 语句的运行过程进行查看
只需要一条数据时使用 LIMIT 1
cursor.execute(&amp;quot;select 1 from user where country='china' limit 1&amp;quot;); 使用索引：
create index ix_tablename_colname on table(col1, col2); 在Join 表时使用相同的类型的字段，并将其索引
如下语句中，两个 state 中应该是创建过索引的，而且是相同的类型，相同的字符集 cursor.execute(&amp;#34;select company_name from users left join conpanies on (users.state=companies.state) where users.</description></item><item><title>Nginx_uwsgi</title><link>http://lanms.github.io/docs/00-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/nginx_uwsgi/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/00-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/nginx_uwsgi/</guid><description>Nginx+uwsgi安装配置 # yum install epel-release &amp;amp;&amp;amp; yum install nginx &amp;amp;&amp;amp; systemctl start nginx &amp;amp;&amp;amp; firewall-cmd --permanent --zone=public --add-service=http &amp;amp;&amp;amp; firewall-cmd --permanent --zone=public --add-service=https &amp;amp;&amp;amp; firewall-cmd --reload &amp;amp;&amp;amp;systemctl enable nginx &amp;amp;&amp;amp; pip3 install uwsgi &amp;amp;&amp;amp; ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi 4.1 配置nginx.conf文件 # 首先：编写自己项目的nginx.conf文件如下：
每一个项目对应有一个自己定义的nginx的配置文件，比如爱鲜蜂项目，我定义为axfnginx.conf文件
server { listen 80; server_name 39.104.176.9 localhost; access_log /home/logs/access.log; error_log /home/logs/error.log; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8890; } location /static/ { alias /home/src/axf/static/; expires 30d; } } 其次：修改总的nginx的配置文件，让总的nginx文件包含我们自定义的项目的axfnginx.</description></item><item><title>rabbitmq使用</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/rabbitmq%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/rabbitmq%E4%BD%BF%E7%94%A8/</guid><description>参考链接
https://tests4geeks.com/python-celery-rabbitmq-tutorial/
# 安装 sudo apt-get install rabbitmq-server # 设置用户和权限 # add user &amp;#39;jimmy&amp;#39; with password &amp;#39;jimmy123&amp;#39; $ rabbitmqctl add_user jimmy jimmy123 # add virtual host &amp;#39;jimmy_vhost&amp;#39; $ rabbitmqctl add_vhost jimmy_vhost # add user tag &amp;#39;jimmy_tag&amp;#39; for user &amp;#39;jimmy&amp;#39; $ rabbitmqctl set_user_tags jimmy jimmy_tag # set permission for user &amp;#39;jimmy&amp;#39; on virtual host &amp;#39;jimmy_vhost&amp;#39; $ rabbitmqctl set_permissions -p jimmy_vhost jimmy &amp;#34;.*&amp;#34; &amp;#34;.*&amp;#34; &amp;#34;.*&amp;#34;</description></item><item><title>requirement</title><link>http://lanms.github.io/docs/09-%E7%88%AC%E8%99%ABscrapy/requirement/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/09-%E7%88%AC%E8%99%ABscrapy/requirement/</guid><description/></item><item><title>scrapyd使用方法</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/scrapyd%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/scrapyd%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>scrapyd使用方法
发布爬虫任务
scrapyd-deploy 001 -p lianjiaSpider
打包egg文件
scrapyd-deploy --build-egg lianjia.egg
1 启动
scrapyd
2 发布工程到scrapyd
scrapyd-deploy &amp;lt;target&amp;gt; -p &amp;lt;project&amp;gt;
scrapyd-deploy scrapyd1 -p Crawler 3 验证是否发布成功
scrapyd-deploy -L &amp;lt;target&amp;gt;
scrapyd-deploy -L scrapyd1
也可以 scrapyd-deploy -l
4 启动爬虫
curl http://192.168.2.333:6800/schedule.json -d project=Crawler -d spider=CommonSpider 5 终止爬虫
curl http://192.168.2.333:6800/cancel.json -d project=Crawler -d job8270364f9d9811e5adbf000c29a5d5be 参考链接 使用scrapyd
https://www.jianshu.com/p/f0077adb74bb</description></item><item><title>shell脚本语言</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</guid><description>shell脚本编辑
变量定义 数字字母下划线, 不能数字开头,不能使用关键字 使用定义过的变量只要在变量名前加 $ 即可 $(ls ) 将当前目录下的文件遍历出来 去变量值 $ 变量边界 ${} 子符长度${#} 去元素 ${数组名[下标]} $ 的使用
$#传递到脚本的参数 $*以一个单字符串显示向脚本传递的参数, 即 传递给脚本的参数组装 $$脚本运行的进程号 $!后台运行的最后一个进程号 **test命令 ** 可参考菜鸟教程shell test 命令
数值测试
-eq 等于则为 true equal -ne 不等于 true not equal -gt 大于为true great -ge 大于等于 true great equal -lt 小于 true little -le小于等于 true little equal 字符串测试
= !</description></item><item><title>spiderKeeper接口</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/spiderkeeper%E6%8E%A5%E5%8F%A3/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/spiderkeeper%E6%8E%A5%E5%8F%A3/</guid><description>创建项目
create project url: /project/create method: post form 上传egg文件
deploy submit upload egg url: /project/1/spider/upload method: post form 删除项目
manage delete project url: /project/1/delete method: get 创建定时任务
Periodic Jobs add job 创建定时任务 url: /project/1/job/add/ method: post form 运行一次
run once create url : /project/1/job/add method: post form 停止任务
/project/1/jobexecs/3/stop 查看日志
log url: /project/1/jobexecs/1/log method: get 和scrapyd通讯文件
app =&amp;gt; proxy =&amp;gt; contrib =&amp;gt; scrapy.</description></item><item><title>Untitled</title><link>http://lanms.github.io/docs/03-git/untitled/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/untitled/</guid><description/></item><item><title>一些函数的用法</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</guid><description>一些函数的用法
hasattr(s, name) # 判断有没有 属性或方法 getattr(s, name) # 获取 setattr(s, name) # 设置</description></item><item><title>临时笔记</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/</guid><description>Linux 操作系统 # 基本知识
$ 普通用户 超级用户 # shell 脚本起始都是 #! /bin/bash
shell 脚本执行 # bash myScript.sh chmod 755 myScript.sh ./myScript.sh 先授予执行权限，再执行脚本 chmod a+x sample.sh ./sample.sh 也可以使用脚本的完整路径进行执行脚本，如：/home/path/script.sh echo # 用于终端打印的基本命令，默认情况下 echo 会在每次调用后添加一个换行符 echo &amp;lsquo;hello&amp;rsquo; echo -n 禁止添加换行符 echo -e 使用转义序列,转义序列可生效 echo -e &amp;ldquo;1\t2\t3&amp;rdquo; 打印彩色输出 echo -e &amp;ldquo;\e[1;31m This is red text \e[0m&amp;rdquo; \e[1;31m 是一个转义字符，可以将颜色设置为红色，\e[0m 是将颜色重置 重置 0 ，黑色 40，红色 41，绿色 42，黄色 43，蓝色 44，洋红 45， 青色 46，白色47 printf # 用于接受引用文本或由空格分隔的参数，可以使用格式化字符串的方法来输出个格式化字符，它不会添加换行符，必须手动指定 格式化输出 printf %-5s 输出占5个字符的长度</description></item><item><title>单元测试</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>单元测试
白盒测试和黑盒测试
白盒测试：是通过程序的源代码进行测试而不使用用户界面。这种类型的测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。黑盒测试：又被称为功能测试、数据驱动测试或基于规格说明的测试，是通过使用整个软件或某种软件功能来严格地测试, 而并没有通过检查程序的源代码或者很清楚地了解该软件的源代码程序具体是怎样设计的。测试人员通过输入他们的数据然后看输出的结果从而了解软件怎样工作 Python的单元测试模块 UnitTest # test case , test suit, test runner, test fixture 测试用例：
继承 unittest.TestCase 内部定义以test_开头的方法，每个test case 都是单独运行，如果一个class中有多个 test_XXX 那么最后在load到suit时也会有多个测试 覆盖度越高越准确 测试运行后的输出：
第一行给出每个用力执行后的标识，成功时 . ，出错时 E，失败时 F, 跳过时 S 在unittest.main() 中可以添加 verbosity 参数，控制最后报告的详细程度，默认时1，0表示不输出每一个用例的执行结果，2 输出详细的执行结果 使用test suite
if __name__ == &amp;#39;__main__&amp;#39;: suite = unittest.TestSuite() # 定义测试的内容列表 tests = [TestMathFunc(&amp;#39;test_add&amp;#39;), TestMathFunc(&amp;#39;test_minus&amp;#39;)] # 添加到测试中，addTest 可以添加单个 suite.</description></item><item><title>各种数据库读写分离小结</title><link>http://lanms.github.io/docs/04-%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%B0%8F%E7%BB%93/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/04-%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%B0%8F%E7%BB%93/</guid><description>数据库读写分离设置 # MySQL # # master配置 server-id=200 # 一般取IP的最后一组数字 innodb_flush_log_at_trx_commit=2 sync_binlog=1 log-bin=mysql-bin-200 binlog-do-db= # 同步的数据库的名称,全部可以使用 * 重启MySQL # 客户端执行命令,授权给 slave grant replication slave on *.* to &amp;#39;zhang&amp;#39;@&amp;#34;IP&amp;#34; identified by &amp;#39;123456&amp;#39;; show master status; # slave 更改配置 server-id=201 innodb_flush_log_at_trx_commit=2 sync_binlog=1 log-bin=mysql-bin-201 # slave mysql客户端执行命令 change master to master_host=&amp;#39;10.7.152.77&amp;#39;, # 连接 master的 IP master_user=&amp;#39;zhang&amp;#39;, # master授权的用户 master_password=&amp;#39;123456&amp;#39;, # 密码 master_log_file=&amp;#39;mysql-bin-200.000002&amp;#39;, # master 的日志位置 master_log_pos=448; # master 的 Position start salve; show slave status\G; # 查看状态 Redis # 通过修改conf文件来配置主从, 一般都是在一台服务器上面作为专门的 redis 服务器 启动 redis-server redis.</description></item><item><title>命令</title><link>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/%E5%91%BD%E4%BB%A4/</guid><description/></item><item><title>安装mariaDB</title><link>http://lanms.github.io/docs/00-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/%E5%AE%89%E8%A3%85mariadb/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/00-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/%E5%AE%89%E8%A3%85mariadb/</guid><description>安装MariaDB # 安装命令
yum -y install mariadb mariadb-server 安装完成MariaDB，首先启动MariaDB
systemctl start mariadb 设置开机启动
systemctl enable mariadb 设置密码 # mysql_secure_installation Enter current password for root:&amp;lt;–初次运行直接回车 设置密码 Set root password? [Y/n] &amp;lt;– 是否设置root用户密码，输入y并回车或直接回车 New password: &amp;lt;– 设置root用户的密码 Re-enter new password: &amp;lt;– 再输入一次你设置的密码 其他配置 Remove anonymous users? [Y/n] &amp;lt;– 是否删除匿名用户，回车 Disallow root login remotely? [Y/n] &amp;lt;–是否禁止root远程登录,回车, Remove test database and access to it? [Y/n] &amp;lt;– 是否删除test数据库，回车 Reload privilege tables now? [Y/n] &amp;lt;– 是否重新加载权限表，回车 初始化MariaDB完成，接下来测试登录 mysql -u root -p password 开启远程连接 # 在mysql数据库中的user表中可以看到默认是只能本地连接的，所有可以添加一个新的用户，该用户可以远程访问</description></item><item><title>安装python3</title><link>http://lanms.github.io/docs/00-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/%E5%AE%89%E8%A3%85python3.6/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/00-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/%E5%AE%89%E8%A3%85python3.6/</guid><description>安装python3.6 # 在centos中，系统默认只提供python2.7的版本，但是项目我们使用的python3.6的版本。所有我们自己安装python3
# 安装python3全部命令 root权限 yum -y groupinstall &amp;#34;Development tools&amp;#34; &amp;amp;&amp;amp; yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel &amp;amp;&amp;amp; wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz &amp;amp;&amp;amp; tar -xvJf Python-3.6.2.tar.xz &amp;amp;&amp;amp; cd Python-3.6.2 &amp;amp;&amp;amp; ./configure --prefix=/usr/local/python3 &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install &amp;amp;&amp;amp; ln -s /usr/local/python3/bin/python3 /usr/bin/python3 &amp;amp;&amp;amp; ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 &amp;amp;&amp;amp; yum install python-virtualenv</description></item><item><title>常用命令</title><link>http://lanms.github.io/docs/03-git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/03-git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description/></item><item><title>部署方法</title><link>http://lanms.github.io/docs/08-tornado/%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95/</link><pubDate>Sat, 30 Apr 2022 16:55:47 +0000</pubDate><guid>http://lanms.github.io/docs/08-tornado/%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95/</guid><description>Tornado部署方法 # 因为Tornado是异步的网络框架，性能够好，可以直接放在最外层，但是为了避免阻塞问题，会开多个进程，然后使用 Nginx 做反向代理实现负载均衡。具体可以看这篇文章 Introduction to Tornado 中文翻译。
那么这里就涉及到要开多个Tornado进程的问题，使用Supervisor来做这件事是最简单的。Supervisor 的使用方法可以看这篇文章 Python 进程管理工具 Supervisor 使用教程
另外，如果你需要部署Django或者 Flask，则推荐 Nginx+Gunicorn+Supervisor
Nginx放在最外层，然后使用Supervisor做进程管理，使用Gunicorn启动Django或者Flask，相较于uwsgi 的方法，简单很多，而且Gunicorn可以让你使用Gevent和Tornado来为你的后端实现异步访问，性能直接飙升。
作者：淡水
链接：https://www.zhihu.com/question/21018409/answer/164837163
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</description></item><item><title>(Hu)go Template Primer</title><link>http://lanms.github.io/posts/goisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>http://lanms.github.io/posts/goisforlovers/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>http://lanms.github.io/posts/hugoisforlovers/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>http://lanms.github.io/posts/hugoisforlovers/</guid><description>Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description></item><item><title/><link>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hidden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hidden/</guid><description>This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem.</description></item></channel></rss>