<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>26-微服务 on wiki</title><link>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link><description>Recent content in 26-微服务 on wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>go内存模型</title><link>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/go%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>share memory by communicating
通过通信共享内存
使用go channel 通信
channels # channels是一种类型安全的消息队列，充当两个goroutine直接的通道 无缓冲 # 不设置 chan的缓冲，接受者和发送者必须是同步的 用于同步通讯 make(chan struct{}{}) buffered channels # make(chan string, 2) Send先于Receive发生 好处: 延迟更小 代价: 不保证数据到达，越大的buffer, 越小的保障到达, buffer = 1 时，给你延迟一个小时的保障 并不是buffer越大性能越好</description></item><item><title>go异常处理</title><link>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/go%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/go%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid><description>使用 github.com/pkg/erros, 可以说向错误添加上下文，这个方式可以由人也可以由机器检查
// 包含堆栈信息 errors.Wrap(err, &amp;#34;xxx异常&amp;#34;) errors.Wrapf(err, &amp;#34;xxx异常 %s&amp;#34;, &amp;#34;xxxx&amp;#34;) // 只包含异常信息 errors.WithMessage(err, &amp;#34;xxx异常&amp;#34;) // 打印异常信息 fmt.Printf(&amp;#34;original error: %T %v\n&amp;#34;, err.Cause(err), errors.Cause(err)) fmt.Printf(&amp;#34;stack trace: \n%+v\n&amp;#34;, err)</description></item><item><title>reids大集群方案</title><link>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/reids%E5%A4%A7%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/reids%E5%A4%A7%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/</guid><description>由于redis核心是单线程，想要最大化使用redis的性能，最好使用 1核2G 的实例组成redis集群使用redis
实例数小于500
推荐使用redis官方的redis-cluster方案 大于500
在redis实例集群上做一层proxy， 通过porxy路由到对应的redis实例中 redis大集群持久化问题
首先应该遵循redis的协议 有一块超大的缓存作为内存 内存和rocksDB进行数据交换</description></item><item><title>多租户(影子发布)</title><link>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%BD%B1%E5%AD%90%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%BD%B1%E5%AD%90%E5%8F%91%E5%B8%83/</guid><description>影子服务
同一个服务的测试/预发布pod 通过流量路由方式实现 可以通过在header中添加特殊标志实现 不影响正常路由 如果要对数据库操作或者对用户有影响，应该mock掉对应有影响的服务，数据库使用新的镜像数据库 影子服务发布流程</description></item><item><title>工程项目结构</title><link>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mmzhang.github.io/docs/26-%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</guid><description/></item></channel></rss>