<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>10-优化 on 工具书-mlzhang</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/</link><description>Recent content in 10-优化 on 工具书-mlzhang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>Celery和RabbitMQ</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/celery%E5%92%8Crabbitmq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/celery%E5%92%8Crabbitmq/</guid><description>Celery和RabbitMQ
Celery是Distributed Task Queue，分布式任务队列，分布式决定了可以有多个 worker 的存在，队列表示其是异步操作，即存在一个产生任务提出需求的 master，和很多的等待分配的 工人
在 Python 中定义Celery，引入了 Broker 中间件，当 worker 处理完之后还会有一个 backend
任务模块 Task
包含异步任务和定时任务，其中，异步任务通常在业务逻辑中被触发并投放在任务队列中，而定时任务也会有 Celery Beat 进程周期性地将任务发往任务队列
消息中间件 Broker
任务调度队列，官方推荐使用 RabbitMQ和Redis等
任务执行单元 Worker
监控消息队列，获取队列中调度的任务，并执行它
任务结果 Backend
存储任务处理的结果，存储也可以使用RabbitMQ，Redis, MongoDB
# 安装 RabbitMQ sudo apt-get install rabbitmq-server # 启动 sudo rabbitmq-server -detached # 停止 sudo ranbbitmqctl stop # 设置 RabbitMQ sudo rabbitmqctl add_user USER_NAME PASSWORD #创建用户 sudo rabbitmqctl add_vhost VHOST_NAME # 添加 vhost 的名称 sudo rabbitmqctl set_user_tags USER_NAME USER_TAGS_NAME # 添加tags sudo rabbitmqctl set_permissions VHOST_NAME USER_NAME &amp;#39;.</description></item><item><title>jsonp跨域请求的处理</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/jsonp%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/jsonp%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/</guid><description/></item><item><title>MySQL主从分离</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/</guid><description>MySQL主从分离，读写分离
Orical适合做集群，没有主从
磁盘阵列，raid
数据库日志 # 错误日志，数据日志，慢查询日志，启动日志
数据日志
全量备份：全部备份，每周 增量备份：每天，将增加的部分进行备份，日志中会记录每个对数据库的操作记录， 冷备份：关掉数据库备份 热备份：不关数据库备份 主从分离配置 # # master配置 server-id=200 # 一般取IP的最后一组数字 innodb_flush_log_at_trx_commit=2 sync_binlog=1 log-bin=mysql-bin-200 binlog-do-db= # 同步的数据库的名称,全部可以使用 * 重启MySQL # 客户端执行命令,授权给 slave grant replication slave on *.* to &amp;#39;zhang&amp;#39;@&amp;#34;IP&amp;#34; identified by &amp;#39;123456&amp;#39;; show master status; # slave 更改配置 server-id=201 innodb_flush_log_at_trx_commit=2 sync_binlog=1 log-bin=mysql-bin-201 # slave mysql客户端执行命令 change master to master_host=&amp;#39;10.7.152.77&amp;#39;, # 连接 master的 IP master_user=&amp;#39;zhang&amp;#39;, # master授权的用户 master_password=&amp;#39;123456&amp;#39;, # 密码 master_log_file=&amp;#39;mysql-bin-200.000002&amp;#39;, # master 的日志位置 master_log_pos=448; # master 的 Position start salve; show slave status\G; # 查看状态 Nginx</description></item><item><title>MySQL优化</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%BC%98%E5%8C%96/</guid><description>MySQL优化 # SQL优化 参数配置优化 对sql语句进行优化 # 缓存查询语句：
不开启缓存的情况：cursor.execute(&amp;quot;select username from user where singup_data&amp;gt;=curdate()&amp;quot;); 开启缓存进行查询：cursor.execute(&amp;quot;select * from user where signup_data&amp;gt;=%s&amp;quot;, (datetime.now()))但是有时会有 sql 注入攻击的风险 EXPLAIN：对要执行的 sql 语句的运行过程进行查看
只需要一条数据时使用 LIMIT 1
cursor.execute(&amp;quot;select 1 from user where country='china' limit 1&amp;quot;); 使用索引：
create index ix_tablename_colname on table(col1, col2); 在Join 表时使用相同的类型的字段，并将其索引
如下语句中，两个 state 中应该是创建过索引的，而且是相同的类型，相同的字符集 cursor.execute(&amp;#34;select company_name from users left join conpanies on (users.state=companies.state) where users.id=%s&amp;#34;, (user_id)) 避免使用 select * ， 使用具体的属性进行查询，避免 select * 的二次查询
每张表都应该创建一个 主键 id</description></item><item><title>临时笔记</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/</guid><description>Linux 操作系统 # 基本知识
$ 普通用户 超级用户 # shell 脚本起始都是 #! /bin/bash
shell 脚本执行 # bash myScript.sh chmod 755 myScript.sh ./myScript.sh 先授予执行权限，再执行脚本 chmod a+x sample.sh ./sample.sh 也可以使用脚本的完整路径进行执行脚本，如：/home/path/script.sh echo # 用于终端打印的基本命令，默认情况下 echo 会在每次调用后添加一个换行符 echo &amp;lsquo;hello&amp;rsquo; echo -n 禁止添加换行符 echo -e 使用转义序列,转义序列可生效 echo -e &amp;ldquo;1\t2\t3&amp;rdquo; 打印彩色输出 echo -e &amp;ldquo;\e[1;31m This is red text \e[0m&amp;rdquo; \e[1;31m 是一个转义字符，可以将颜色设置为红色，\e[0m 是将颜色重置 重置 0 ，黑色 40，红色 41，绿色 42，黄色 43，蓝色 44，洋红 45， 青色 46，白色47 printf # 用于接受引用文本或由空格分隔的参数，可以使用格式化字符串的方法来输出个格式化字符，它不会添加换行符，必须手动指定 格式化输出 printf %-5s 输出占5个字符的长度</description></item><item><title>单元测试</title><link>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/10-%E4%BC%98%E5%8C%96/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>单元测试
白盒测试和黑盒测试
白盒测试：是通过程序的源代码进行测试而不使用用户界面。这种类型的测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。黑盒测试：又被称为功能测试、数据驱动测试或基于规格说明的测试，是通过使用整个软件或某种软件功能来严格地测试, 而并没有通过检查程序的源代码或者很清楚地了解该软件的源代码程序具体是怎样设计的。测试人员通过输入他们的数据然后看输出的结果从而了解软件怎样工作 Python的单元测试模块 UnitTest # test case , test suit, test runner, test fixture 测试用例：
继承 unittest.TestCase 内部定义以test_开头的方法，每个test case 都是单独运行，如果一个class中有多个 test_XXX 那么最后在load到suit时也会有多个测试 覆盖度越高越准确 测试运行后的输出：
第一行给出每个用力执行后的标识，成功时 . ，出错时 E，失败时 F, 跳过时 S 在unittest.main() 中可以添加 verbosity 参数，控制最后报告的详细程度，默认时1，0表示不输出每一个用例的执行结果，2 输出详细的执行结果 使用test suite
if __name__ == &amp;#39;__main__&amp;#39;: suite = unittest.TestSuite() # 定义测试的内容列表 tests = [TestMathFunc(&amp;#39;test_add&amp;#39;), TestMathFunc(&amp;#39;test_minus&amp;#39;)] # 添加到测试中，addTest 可以添加单个 suite.addTests(tests) # 定义 runner 执行测试 runner = unittest.TextTestRunner(verbosity=2) runner.run(suite) 测试环境准备 # setUp和tearDown
在每个测试用例开始和结束时执行的方法，用于测试环境的准备，清理环境 setUpClass和tearDownClass</description></item></channel></rss>