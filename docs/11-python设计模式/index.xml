<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>11-Python设计模式 on 工具书-mlzhang</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 11-Python设计模式 on 工具书-mlzhang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>00-Python设计模式介绍</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</guid><description>简介 # Python的设计模式可以分为三大类，创建型模式，结构型模式，行为型模式
创建型模式 # 介绍处理对象创建的设计模式，具体有：
工厂模式 建造者模式 原型模式 结构型模式 # 介绍处理一个系统中不同实体（类、对象等）之间的关系，具体有：
适配器模式 修饰器模式 外观模式 享元模式 模型-视图-控制器模式 代理模式 行为型模式 # 介绍处理系统实体之间通信的设计模式，具体有：
责任链模式 命令模式 解释器模式 观察者模式 状态模式 策略模式 模板模式</description></item><item><title>01-工厂模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>01-工厂模式
介绍 # 在工厂模式中，客户端可以请求一个对象，而无需知道这个对象来自哪里，也就是，使用那个类来生成这个对象，共仓背后的思想是简化对象的创建，与客户端自己基于类实例化直接创建对象相比，基于一个中心化函数来实现，更易于追踪创建了那些对象，通过将创建对象的代码和使用对象的代码解耦，工厂能够降低应用维护的复杂度。
工厂通常由两种方式，一种是工厂方法，它是一个方法，对不同的输入参数返回不同的对象，第二种是抽象工厂，它是一组用于创建一系列相关事务的工厂方法
1. 工厂方法 # 案例：Django框架工厂方法来创建表单字段，Django的forms模块支持不同类型的字段（CharField, EmailField）的创建和定制（max_length, required）。
何时使用 # 如果因为应用创建对象的代码分布在多个不同的地方，而不是仅在一个函数/方法中，你发现没法跟踪这些对象，那么因该考虑使用工厂方法模式
代码示例 https://github.com/lanms/Python_design_pattern/blob/master/01_factory_pattern/factory_method.py
2. 抽象工厂 # 抽象工厂设计模式是抽象方法的一种泛化
抽象工厂有一个有点，在使用工厂方法时从用户的视角通常是看不到的，那么就是抽象工厂能够通过改变激活的工厂方法动态的改变应用行为。
何时使用 # 通常一开始使用的是工厂方法，因为它更加简单，如果后来发现应用需要许多工厂方法，那么将创建一系列对象的过程合并在一起，而最终引入抽象方法。
代码示例https://github.com/lanms/Python_design_pattern/blob/master/01_factory_pattern/abstract_factory.py</description></item><item><title>02-建造者模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>建造者模式对比工厂模式 # 建造者模式对比工厂模式两者之间的差别并不明确，主要的区别在于工厂模式以单个步骤创建对象，而建造者模式以多个步骤创建对象，并且几乎始终会使用一个指挥者。另外一个区别是，在工厂模式中会立即返回一个创建好的对象，而在建造模式下，仅在需要客户端代码显示是才会请求指挥者返回最终的对象，可类比Django对数据库的操作
适用场景 # 想要创建一个复杂对象，对象由多个部分构成，且对象的创建要经过多个不同的步骤，这些步骤也许还需要遵从特定的顺序 要求一个对象能有不同的表现，并希望对象的构造与表现解耦 想要在某个时间点创建对象，但是在稍后的时间再做访问，延时生产 代码示例 https://github.com/lanms/Python_design_pattern/blob/master/02_builder_pattern/builder_pizza.py</description></item><item><title>03-原型模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>介绍 # 通过对传入的对象做深拷贝， 并且通过内部的更改对象属性的方法来使原始传入的对象的副本进行加工，最终在原始对象的原型的基础上得到新的对象
原型模式用于创建对象的完全副本，确切的说，创建一个对象的副本可以指代以下两件事
当创建一个浅副本时，副本依赖引用 当创建一个深副本时，副本复制所有的东西 第一种情况，我们关注提升应用性能和优化内存使用，在对象之间引入数据共享，单需要小心的修改数据，因为所有的改变对所有的副本都是可见的。
第二种情况中，我们希望能够对一个副本进行更改而不会影响其他对象。
代码示例https://github.com/lanms/Python_design_pattern/blob/master/03_prototype_pattern/prototype.py</description></item><item><title>04-适配器模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>介绍 # 适配器模式是一种结构型设计模式，帮助我们实现两个不兼容接口之间的兼容，实际就是将原来的对象转换为后者可以使用的对象
将不同的对象实例化，并且赋予同样的接口指向对象内部不同的方法，实现统一方法不同的返回的适配器效果
代码示例https://github.com/lanms/Python_design_pattern/blob/master/04-adapter.py</description></item><item><title>05-修饰器模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05-%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05-%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>修饰器模式 # 和继承相比，通常因该优先选择组合，因为继承使得代码更加难复用，继承关系是静态的。修时器模式能够以透明的方式动态的将功能添加到一个对象中，对该对象的功能进行扩展。
代码示例https://github.com/lanms/Python_design_pattern/blob/master/05-deactor_pattern.py</description></item><item><title>06-外观模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式 # 系统会随着演化变得非常复杂，最终代码内部的类有大量的交互，错综复杂，不适合将其暴露给客户，外观设计模式有助于隐藏系统的内部复杂性，并通过一个简化的接口向客户端提供数据。本质上，外观模式是在已有的复杂系统上实现的一个抽象层。
外观模式常用于给一个复杂的系统提供简单的接口
核心实现方法是使用，抽象方法在类中实现固定接口，将其他没必要暴露在外的方法都交给类内部自己实现，在调用需要实现类中的功能的时候只需要将类中暴露出来的方法进行实现即可
代码示例https://github.com/lanms/Python_design_pattern/blob/master/06-face_pattern.py</description></item><item><title>07-享元模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid><description>享元模式 # 介绍 # 享元模式通过为相似对象引入数据共享来最小化内存使用，提升性能，一个享元就是一个包含状态的独立的不可变数据的共享对象，依赖状态的可变数据不应是享元的一部分，因为每个对象的这种信息不相同，无法共享，如果享元需要非固有数据应该由客户端代码显示提供。
例如我们正在设计一个性能为关键的游戏，例如第一人称设计游戏（FPS），在FPS游戏中，玩家（士兵）共享一些状态，如外在的表现和行为。例如在 CS 游戏中，同一团队的所有士兵看起来都是一样的，所有的士兵都有一些共同 的动作，比如，低头，跳跃等，这意味着我们可以创建一个享元来包含所有的共同数据，当然，士兵也有许多因人而异的数据，这些数据不是享元的一部分，比如，枪支/健康状况和地理位置等。
应用场景 # 享元旨在优化性能和内存的使用。所有的嵌入式系统（如手机，平板，游戏终端和微控制器等）还有和性能相关的应用，如游戏，3D图形处理和实时系统等，都能从其中获益。
享元模式的使用条件：
应用需要使用大量的对象 对象太多，存储/渲染它们的代价太大，一旦移除对象中的可变形态，多组不同的对象可以被相对更少的共享对象所替代。 对象的ID对于应用不重要，对象共享改会造成ID的比较失败，所以不能依赖对象的ID。 关于memoization与享元模式之间的区别 # memoization是一种优化技术，使用一个缓存来避免重复计算已经在前期步骤中计算好的结果，memoization并不是只能应用于某种特定的编程方式，还可以应用于方法和简单的函数。享元则是一种特定于面向对象编程优化的审计模式，享元关注的是共享的诗句。
享元的实现 # 在Python中，享元可以以多种方式实现
代码示例https://github.com/lanms/Python_design_pattern/blob/master/07-share_pattern.py
def __new__(cls, tree_type): obj = cls.pool.get(tree_type, None) if not obj: obj = object.__new__(cls) cls.pool[tree_type] = obj obj.tree_type = tree_type return obj # pool 是一个类属性，使用 __new__ 把 Tree 变成一个元类，元类支持自引用，cls 引用的是 Tree 类， # 当客户端需要创建一个 Tree实例时，会以 Tree_type 参数传递树的种类， # 树的种类用于检查是否创建过相同的树，如果已经创建过，则返回之前创建的对象， # 否则，将这种新的树种添加到池中，并创建新的对象 一句话总结 # 享元模式就是通过避免重复创建大量的已有的实列来优化程序的结构和性能，Python中可以使用元类来创建，类似于单例模式</description></item><item><title>08-MVC模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08-mvc%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08-mvc%E6%A8%A1%E5%BC%8F/</guid><description>MVC模式 # 模型-视图-控制器模式
SoC 关注点分离（Separation of Concerns）是软件工程相关设计原则之一。SoC原则背后的思想是将一个应用切分成不同的部分，每个部分解决一个单独的关注点。分层设计中的层次即是关注点的例子，使用SoC原则能简化软件应用的开发和维护。
MVC就是应用到面向对象编程的SoC原则。
模型是核心部分，代表着应用的信息本源，包含和管理业务逻辑，数据，状态以及应用的规则。
视图是模型的可视化表现。
控制器是模型和视图之间的链接。模型和视图之间的信息交互都是由控制器进行控制。
总结 # MVC模式将各个模块的功能进行解耦和，方便应用的管理和代码的扩展</description></item><item><title>09-代理模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式 # 在某些应用中我们想要访问一个或者多个重要的操作，有时会进行一些敏感操作，在允许用户进行这些敏感操作的之前，我们希望确保用户具备足够的权限，操作系统也存在这样的情况，如在执行某些操作的时候必须有管理员权限才可以进行。
常见的知名代理模式 # 远程代理：实际存在于不同地址空间的对象在本地的代理 虚拟代理：用于懒初始化，将一个大计算量对象的创建延迟到真正需要的时候 保护/防护代理：控制对敏感对象的访问 智能（引用）代理：在对象被访问时执行额外的动作，此类代理的例子包括引用计数和线程安全检查。 虚拟代理，代码示例https://github.com/lanms/Python_design_pattern/blob/master/09-proxy_pattern/09-1-Lazy.py
代理模式代码 https://github.com/lanms/Python_design_pattern/blob/master/09-proxy_pattern/09-2-proxy.py</description></item><item><title>10-责任链模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid><description>责任链模式 # 当在开发中无法预知使用哪种方法处理某个特定的请求时，使用责任链模式来不停的进行吹，直到有合适的处理方法为止
原则：
存在一个对象链 我们一开始将请求发送给链中的第一个对象 对象决定是否要处理该请求 将请求传递给下一个对象 重复该过程，一直到链尾 code https://github.com/lanms/Python_design_pattern/blob/master/10_chain_pattern.py</description></item><item><title>11-命令模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid><description>命令模式 # 只需要执行一个命令，就可以实现对应的功能 调用命令的对象知道如何执行命令的对象解耦，调用者无需知道命令的任何实现细节 如果有意义，可以把多个命令组织起来，这样调用者能够按照顺序执行它们 code https://github.com/lanms/Python_design_pattern/blob/master/11_command_pattern.py</description></item><item><title>12-解释器模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>解释器模式 # 客户分类：
基本用户 高级用户 解释器模式主要是引起应用的高级用户的兴趣
code https://github.com/lanms/Python_design_pattern/blob/master/12_interpreter_pattern.py</description></item><item><title>13-观察者模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>观察者模式 # 在一个对象的状态改变时可以改变另外一组对象
观察者模式描述单个对象与一个或多个对象之间的发布订阅关系。在MVC的例子中，发布者是模型，订阅者是视图。
观察者模式希望一个对象的状态变化时，能够通知/提醒多有相关者，则可以使用观察者模式，观察者模式的一个重要特性为，在运行时，订阅者/观察者的数量以及观察者时谁都会发生变化。
code https://github.com/lanms/Python_design_pattern/blob/master/13_observer_pattern.py</description></item><item><title>14-状态模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid><description>状态模式 #</description></item><item><title>15-策略模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid><description/></item><item><title>16-模板模式</title><link>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</guid><description/></item></channel></rss>