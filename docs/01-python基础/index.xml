<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>01-python基础 on 工具书-mlzhang</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/</link><description>Recent content in 01-python基础 on 工具书-mlzhang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml"/><item><title>01-字符串操作-os文件操作-时间日期对象-面向对象-这正则</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-os%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%99%E6%AD%A3%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-os%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%99%E6%AD%A3%E5%88%99/</guid><description>1. str 字符串操作 # 常见的字符串函数 zip l = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;] b = zip(l[:-1], l[1:]) print(dict(b)) # 可以映射成字典,元组,列表 {&amp;#39;a&amp;#39;: &amp;#39;b&amp;#39;, &amp;#39;b&amp;#39;: &amp;#39;c&amp;#39;, &amp;#39;c&amp;#39;: &amp;#39;d&amp;#39;, &amp;#39;d&amp;#39;: &amp;#39;e&amp;#39;, &amp;#39;e&amp;#39;: &amp;#39;f&amp;#39;} str1.split()： 过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 str1.splitlines(): 按照行(&amp;#39;\r&amp;#39;, &amp;#39;\r\n&amp;#39;, \n&amp;#39;)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 str1.join(): 用于将序列中的元素以指定的字符连接生成一个新的字符串。 max(): 返回给定参数的最大值，参数可以为序列 min(): 返回字符串中最小的字母。 str1.replace(old, new[, max]): 把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 str1.</description></item><item><title>02-函数-reduce()-map()-nonloca</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/02-%E5%87%BD%E6%95%B0-reduce-map-nonloca/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/02-%E5%87%BD%E6%95%B0-reduce-map-nonloca/</guid><description>介绍 # 主要讲述了一些函数的用法
reduce() map() nonlocal 1. reduce() # reduce 把一个函数作用在一个序列上, 这个函数必须接受两个参数, reduce 把结果和序列的写一个元素做累积计算 # 运用的是递归的思想 不同之处在于 它是将第一次调用函数的结果作为了第二次调用函数的第一个参数, reduce(f, [x1, x2, x3, x4, x5]) = f(f(f( f(x1, x2), x3),x4), x5) 2. map() # map() 得到的是一个 object 需要进行其他的实体化操作才能得需要的值 &amp;gt;&amp;gt;&amp;gt;def square(x) : # 计算平方数 ... return x ** 2 ... # 传入的是函数名 不带() &amp;gt;&amp;gt;&amp;gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 [1, 4, 9, 16, 25] # 传入的时候一个匿名函数 &amp;gt;&amp;gt;&amp;gt; map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数 [1, 4, 9, 16, 25] # 提供了两个列表，对相同位置的列表数据进行相加, map 会自动查找需要是参数 &amp;gt;&amp;gt;&amp;gt; map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [3, 7, 11, 15, 19] 3.</description></item><item><title>03-stringIO</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/03-stringio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/03-stringio/</guid><description> from io import StringIO s = StringIO() s.write(&amp;#39;www.baidu.com\n&amp;#39;) s.write(&amp;#39;abc\n&amp;#39;) s.write(&amp;#39;zhang&amp;#39;) o = s.getvalue() print(o) s.seek(0) # 指定开始读取的位置 while True: strBuf = s.readline() if not strBuf: break print(strBuf, end=&amp;#39;&amp;#39;) s.close() # 另外还有 readline() readlines() 等方法可以读取</description></item><item><title>04-网络编程-TCP-UDP-BS64</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp-udp-bs64/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp-udp-bs64/</guid><description>1. 网络介绍 # 多台独立自主的计算机互联的总称叫计算机网络 实现信息互联与资源共享 网络接口 &amp;ndash;&amp;gt; 网络 &amp;ndash;&amp;gt; 传输 &amp;ndash;&amp;gt; 应用 Inernet 因特网 基于TCP/IP Model 的网络 ​ 1. 1 TCP 可靠传输协议 # 传输控制协议 Transfer Control Protocol
可靠通信(数据不会穿丢也不会传错) 流量控制 自动调节发送数据的速度 拥塞控制 网络拥堵时会降低发送速率 可靠通讯的实现:
如何保证数据不会传输错误 握手机制 + 在数据中添加冗余校验对发送的数据 进行校验 流量控制:
滑动窗口机制 逐步增加发送的数据大小 拥塞控制:
减小滑动窗口 减小发送速率 1.2 UDP # User Datagram Protocol 用户数据宝协议 数据可能会丢失某部分内容 只要不影响使用 列如视屏 不会影响用户的使用 2.</description></item><item><title>05-yield函数</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/05-yield%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/05-yield%E5%87%BD%E6%95%B0/</guid><description>sys # 在Linux系统命令行参数 在输入命令是给的参数 sys.argv 接受所有的参数 保存在数组中 yield # # 生成式 列表已存在,占用空间大 list1 = [x for x in range(10)] #生成器 得到的是 generator 对象 引用 list3 = (x for c in range(10)) for i in list3: # 在需要用的时候再计算出值 print(i) # 生成器函数 def fibo(n): #普通函数 a, b = (0, 1) for _ in range(n): a, b = b, a + b return a def fibo(n): #生成器函数 保留上次计算的值 不会重复计算 a, b = (0, 1) for _ in range(n): a, b = b, a + b yield a string.</description></item><item><title>06-Python操作数据库</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/06-python%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/06-python%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>ORM - Object Relation Mapping 对象关系映射
关系型数据库 - 关系模型 Python 程序 - 对象模型 第三方框架 Alchemy 可以完成对象关系的双向转换,可以直接操作 数据库, 不用写 SQL 语句, 但是会降低性能 关键字 # host / [port] / user / passwd / db / charset / [autocommit / cursorclass=pymysql.cursors.DictCursor]
操作方法 # 调用的是pymysql的connect()/Cursor()方法 创建连接 pymysql.connect() 输入 import pymysql conn = pymysql.connect(host=&amp;#39;localhost&amp;#39;, port=3306,user=&amp;#39;root&amp;#39;, passwd=&amp;#39;123456&amp;#39;, db=&amp;#39;hrs&amp;#39;,charset=&amp;#39;utf8&amp;#39;, autocommit=False) 创建Cursor() cursor.execute() 执行sql语句 try: with conn.</description></item><item><title>07-装饰器</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/07-%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/07-%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>装饰器
一个函数, 两个功能 def func_3(line): def comp(value): if value &amp;gt;= line: print(&amp;#39;{}&amp;gt;= {}&amp;#39;.format(value, line)) else: print(&amp;#39;{}&amp;lt; {}&amp;#39;.format(value, line)) return comp f = func_3(60) # 第一次调用外侧函数 f(89) # 第二次调用内层x # 相当于 func_3(60)(89) 自动将函数的参数放进了中间功能函数的中作为参数 会将实际传入目标函数的参数在装饰器中先传入进行验证, 也就是先执行装饰器的函数, 再执行目标函数 def dec_1(func): def wrapper(num1, num2): if num2 == 0: return (&amp;#39;0000&amp;#39;) return func(num1, num2) return wrapper def average_1(num1, num2): return num1 / num2 # averge_1 = dec_1(average_1) # a = averge_1(5, 0) # print(a) @dec_1 def sum_1(num1, num2): return num1 + num2 a = sum_1(1, 0) print(a) ==接收不同 的参数==</description></item><item><title>08-递归函数</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/08-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/08-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</guid><description>简介 # ​ 一个递归函数的调用过程类似于多个函数的嵌套的调用，只不过调用函数和被调用函数是同一个函数。为了保证递归函数的正确执行，系统需设立一个工作栈。具体地说，递归调用的内部执行过程如下：
运动开始时，首先为递归调用建立一个工作栈，其结构包括值参、局部变量和返回地址； 每次执行递归调用之前，把递归函数的值参和局部变量的当前值以及调用后的返回地址压栈； 每次递归调用结束后，将栈顶元素出栈，使相应的值参和局部变量恢复为调用前的值，然后转向返回地址指定的位置继续执行。 简单来说:
递归就是对函数自身的调用, 但是必须有一个明确的结束条件, 称为递归出口 简单的递归函数
def foo(n): if n == 1: # 最后写中间的条件部分 return 1 return n * foo( n - 1 ) # 优先写递归调用的函数 ===&amp;gt; fact(5) ===&amp;gt; 5 * fact(4) ===&amp;gt; 5 * (4 * fact(3)) ===&amp;gt; 5 * (4 * (3 * fact(2))) ===&amp;gt; 5 * (4 * (3 * (2 * fact(1)))) ===&amp;gt; 5 * (4 * (3 * (2 * 1))) ===&amp;gt; 5 * (4 * (3 * 2)) ===&amp;gt; 5 * (4 * 6) ===&amp;gt; 5 * 24 ===&amp;gt; 120 代码来源, 廖雪峰的官方博客</description></item><item><title>09-线程和进程</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/09-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/09-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</guid><description>线程和进程 # 1. 同步和异步 # 针对结果
同步 - 多任务，多个任务执行的时候有先后的顺序， 必须一个先执行后， 另外一个才能继续执行， 只有一条运行主线 异步 - 多任务， 多个任务之间执行没有想先后顺序， 可以同时运行， 执行时先后顺序不会对程序有什么影响， 存在多条运行主线 2. 阻塞和非阻塞 # 针对运行状态 线程的状态（就绪、运行、阻塞）
阻塞 - 从调用者的角度出发， 如果在调用的时候， 被卡住， 不能再继续往下执行， 需要等待， 就是 阻塞 非阻塞 - 从调用者的角度出发， 如果在调用的时候， 没有被卡住， 能够继续向下执行， 无需等待， 就是 非阻塞 3. 并发和并行 # 并发 - 同时处理任务 并行 - 交替处理任务， 类似线程之间不断切换 并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力,强调的是同时.
下面这篇文章可以参考解释上述概念
https://blog.csdn.net/timemachine119/article/details/54091323
进程和线程使用 # 进程：内存独立， 线程共享同一进程的内存， 一个进程就像是一个应用程序（app） 进程是资源的组合， 线程是执行的单位 进程之间不能直接相互访问， 同一进程中的线程可以相互通讯 创建新的进程很消耗系统资源， 线程非常轻量， 只需要保存线程运行时的必要数据， 如上下文， 程序的堆栈信息 同一进程里的线程可以相互控制， 父进程可以控制子进程 开多进程</description></item><item><title>10-协程和aiohttp</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/10-%E5%8D%8F%E7%A8%8B%E5%92%8Caiohttp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/10-%E5%8D%8F%E7%A8%8B%E5%92%8Caiohttp/</guid><description>关于 GIL # Pyhton的全局解释器锁 协程 # 协程其实就是一个线程， 在执行过程中， 在程序内部中断，然后转而执行别的程序，在适当的时候再返回来接着执行 优势 # 最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 原因 : # cpython解释器中存在一个GIL(全局解释器锁),他的作用就是保证同一时刻只有一个线程可以执行代码, 因此造成了我们使用多线程的时候无法实现并行。 解决方案法 : # 更换解释器 比如使用jpython(java实现的python解释器)
使用多进程完成多任务的处理
Python语言和GIL没有关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
GIL：
全局解释器锁。
每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后, 必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100 Python使用多进程是可以利用多核的CPU资源的。 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁 结论:
在 处理像科学计算 这类需要持续使用cpu的任务的时候 单线程会比多线程快 在 处理像IO操作等可能引起阻塞的这类任务的时候 多线程会比单线程 yield函数 # 生成器函数， 可以理解为暂停，程序会暂停在yield的地方， 等待下一次调用 next() 时， 程序又会执行一次， 然后继续执行 可以通过打断点来进行理解， 让程序一步一步执行， 查看程序到底执行到了那里， 暂停到了那里</description></item><item><title>11-元类</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/11-%E5%85%83%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/11-%E5%85%83%E7%B1%BB/</guid><description>元类介绍 # type可以直接生成类（class），但也可以先生成元类（metaclass），再使用元类批量定制类（class）
使用 class 创建类
class Hello(): def say(self, name=&amp;#39;world&amp;#39;): print(&amp;#39;Hello, %s&amp;#39; % name) h = Hello() h.say() 使用 type 直接创建
def say(self, name=&amp;#39;world&amp;#39;): print(&amp;#34;Hello, %s&amp;#34; % name) Hello = type(&amp;#39;Hello&amp;#39;, (object, ), dict(say_hello=say)) h = Hello() h.say() 先生成元类 metaclass，再批量创建
# 传入type class SayMetaClass(type): # 传入 类名称、父类、属性 def __new__(cls, name, bases, attrs): # 添加属性 attrs[&amp;#39;say_&amp;#39;+name] = lambda self,value,saying=name: print(saying+&amp;#39;,&amp;#39;+value+&amp;#39;!</description></item><item><title>12-Anaconda创建虚拟环境</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/12-anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/12-anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid><description>下载安装 # https://www.jianshu.com/p/920a6e18cfd6 (参考文档)
下载地址： https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/ 下载最新的windows版本
安装过程如果没有选择添加环境变量，那么需要手动添加一下环境变量
常用命令 # conda -V (大写) 查看版本
conda list 查看安装了哪些包
conda env list 或 conda info -e 查看当前存在哪些虚拟环境
conda update conda 检查更新当前的conda
创建Python虚拟环境 # conda create -n your_env_name python=X.X(版本) 创建指定Python版本的虚拟环境
激活 activate your_env_name
对指定虚拟环境安装扩展包 # conda install -n your_env_name [package_name]
卸载指定的安装包 # conda remove -n your_env_name &amp;ndash;all 全部卸载
conda remove &amp;ndash;name your_env_name [package_name] 卸载某个包</description></item><item><title>13-py2和py3的区别</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/13-py2%E5%92%8Cpy3%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/13-py2%E5%92%8Cpy3%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>python3和python2的区别 # 注：没有特别说明的都是 python3 的特性
性能 # 2的性能比3的性能高越 15%-30%
编码 # 3使用的是 utf-8
语法 # 去除了&amp;lt;&amp;gt; 全部使用 ！=
全部改用 repr() 去除 ``
加入关键子 as和with, 还有True,False None
整型相除得到的是浮点数， // 得到的是整型
加入 nolocal
将print关键子去除，添加 print() 方法
print &amp;ldquo;This is&amp;rdquo;, 2*2 print &amp;raquo; sys.stderr. &amp;lsquo;fatal error&amp;rsquo; 3.X print(&amp;ldquo;fatal error&amp;rdquo;, file=sys.stderr) x &amp;lt; y 当 x 和 y 的类型不匹配抛出 Typeerror 而不是随机的 bool 值
输入函数改变
2 ： raw_input(&amp;ldquo;请输入：&amp;rdquo;) 3 ： input(&amp;ldquo;请输入：&amp;rdquo;) 不能定义函数如下</description></item><item><title>14-函数的用法汇总</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/14-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/14-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/</guid><description>or
取第一个不为空值的变量
a = b or c or d or e callable
验证函数是否是可被调用的方法
&amp;gt;&amp;gt;&amp;gt; callable(max) True &amp;gt;&amp;gt;&amp;gt; callable(9) False</description></item><item><title>15-python内置函数库</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/15-python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/15-python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BA%93/</guid><description>1. functool # 1.1 lru_cache # 当api传入相同参数时，快速返回缓存的值 from urllib import request, error from functools import lru_cache @lru_cache(maxsize=32) def get_pep(num): resource = &amp;#39;http://www.python.org/dev/peps/pep-%04d/&amp;#39; % num try: with request.urlopen(resource) as s: return s.read() except error.HTTPError: return &amp;#34;NOT found {}&amp;#34;.format(num) for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991: pep = get_pep(n) print(f&amp;#34;{n}{len(pep)}{pep}&amp;#34;) 1.</description></item><item><title>shell脚本语言</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</guid><description>shell脚本编辑
变量定义 数字字母下划线, 不能数字开头,不能使用关键字 使用定义过的变量只要在变量名前加 $ 即可 $(ls ) 将当前目录下的文件遍历出来 去变量值 $ 变量边界 ${} 子符长度${#} 去元素 ${数组名[下标]} $ 的使用
$#传递到脚本的参数 $*以一个单字符串显示向脚本传递的参数, 即 传递给脚本的参数组装 $$脚本运行的进程号 $!后台运行的最后一个进程号 **test命令 ** 可参考菜鸟教程shell test 命令
数值测试
-eq 等于则为 true equal -ne 不等于 true not equal -gt 大于为true great -ge 大于等于 true great equal -lt 小于 true little -le小于等于 true little equal 字符串测试
= !</description></item><item><title>一些函数的用法</title><link>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</guid><description>一些函数的用法
hasattr(s, name) # 判断有没有 属性或方法 getattr(s, name) # 获取 setattr(s, name) # 设置</description></item></channel></rss>