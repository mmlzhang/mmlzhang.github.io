<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="关于 GIL #   Pyhton的全局解释器锁  协程 #   协程其实就是一个线程， 在执行过程中， 在程序内部中断，然后转而执行别的程序，在适当的时候再返回来接着执行  优势 #   最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。  原因 : #   cpython解释器中存在一个GIL(全局解释器锁),他的作用就是保证同一时刻只有一个线程可以执行代码, 因此造成了我们使用多线程的时候无法实现并行。  解决方案法 : #    更换解释器 比如使用jpython(java实现的python解释器)
  使用多进程完成多任务的处理
   Python语言和GIL没有关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
  GIL：
  全局解释器锁。
 每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后, 必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100 Python使用多进程是可以利用多核的CPU资源的。 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁  结论:
 在 处理像科学计算 这类需要持续使用cpu的任务的时候 单线程会比多线程快 在 处理像IO操作等可能引起阻塞的这类任务的时候 多线程会比单线程  yield函数 #   生成器函数， 可以理解为暂停，程序会暂停在yield的地方， 等待下一次调用 next() 时， 程序又会执行一次， 然后继续执行  可以通过打断点来进行理解， 让程序一步一步执行， 查看程序到底执行到了那里， 暂停到了那里"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="10-协程和aiohttp"><meta property="og:description" content="关于 GIL #   Pyhton的全局解释器锁  协程 #   协程其实就是一个线程， 在执行过程中， 在程序内部中断，然后转而执行别的程序，在适当的时候再返回来接着执行  优势 #   最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。  原因 : #   cpython解释器中存在一个GIL(全局解释器锁),他的作用就是保证同一时刻只有一个线程可以执行代码, 因此造成了我们使用多线程的时候无法实现并行。  解决方案法 : #    更换解释器 比如使用jpython(java实现的python解释器)
  使用多进程完成多任务的处理
   Python语言和GIL没有关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
  GIL：
  全局解释器锁。
 每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后, 必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100 Python使用多进程是可以利用多核的CPU资源的。 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁  结论:
 在 处理像科学计算 这类需要持续使用cpu的任务的时候 单线程会比多线程快 在 处理像IO操作等可能引起阻塞的这类任务的时候 多线程会比单线程  yield函数 #   生成器函数， 可以理解为暂停，程序会暂停在yield的地方， 等待下一次调用 next() 时， 程序又会执行一次， 然后继续执行  可以通过打断点来进行理解， 让程序一步一步执行， 查看程序到底执行到了那里， 暂停到了那里"><meta property="og:type" content="article"><meta property="og:url" content="http://lanms.github.io/docs/01-python%E5%9F%BA%E7%A1%80/10-%E5%8D%8F%E7%A8%8B%E5%92%8Caiohttp/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2022-04-30T16:55:47+00:00"><meta property="article:modified_time" content="2022-04-30T16:55:47+00:00"><title>10-协程和aiohttp | 工具书-mlzhang</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.e19e6e7d06c383e93fafe5e2111b95b9f5f777782cfa1695d8e500b80c435ad0.js integrity="sha256-4Z5ufQbDg+k/r+XiERuVufX3d3gs+haV2OUAuAxDWtA=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>工具书-mlzhang</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-0bf3c2a49f26dabca6952b870248d3b7 class=toggle>
<label for=section-0bf3c2a49f26dabca6952b870248d3b7 class="flex justify-between"><a role=button>21-vue学习</a></label><ul></ul></li><li><input type=checkbox id=section-777fdc97635e6502949855bc095ee6aa class=toggle>
<label for=section-777fdc97635e6502949855bc095ee6aa class="flex justify-between"><a role=button>20-airflow实战</a></label><ul></ul></li><li><input type=checkbox id=section-5155dad3123cddc005a7f9ed86d6db12 class=toggle>
<label for=section-5155dad3123cddc005a7f9ed86d6db12 class="flex justify-between"><a role=button>19-hugo-book</a></label><ul><li><a href=/docs/19-hugo-book/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/>Hugo搭建博客</a></li><li><a href=/docs/19-hugo-book/github%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%89%98%E7%AE%A1/>Github静态页面托管</a></li><li><a href=/docs/19-hugo-book/%E6%B7%BB%E5%8A%A0%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/>添加阿里云域名解析</a></li></ul></li><li><input type=checkbox id=section-e2a7cdf3c35751c10fd1e5474ec25934 class=toggle>
<label for=section-e2a7cdf3c35751c10fd1e5474ec25934 class="flex justify-between"><a role=button>18-安装脚本</a></label><ul><li><a href=/docs/18-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/nginx_uwsgi/>Nginx_uwsgi</a></li><li><a href=/docs/18-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/%E5%AE%89%E8%A3%85mariadb/>安装mariaDB</a></li><li><a href=/docs/18-%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/%E5%AE%89%E8%A3%85python3.6/>安装python3</a></li></ul></li><li><input type=checkbox id=section-9ae7bb7204f29d395ff4374aa648c2d6 class=toggle>
<label for=section-9ae7bb7204f29d395ff4374aa648c2d6 class="flex justify-between"><a role=button>17-emacs</a></label><ul><li><a href=/docs/17-emacs/emacs%E9%85%8D%E7%BD%AE/>emacs配置</a></li></ul></li><li><input type=checkbox id=section-ad28360255e5707f82f748667937828d class=toggle>
<label for=section-ad28360255e5707f82f748667937828d class="flex justify-between"><a role=button>16-面试题</a></label><ul></ul></li><li><input type=checkbox id=section-7fe75dce01e7dbdc6caf2191b7f35824 class=toggle>
<label for=section-7fe75dce01e7dbdc6caf2191b7f35824 class="flex justify-between"><a role=button>15-集成开发</a></label><ul><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/01-git_flow%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/>01-git_flow工作流使用指南</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/02-jenkins%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%9701/>02-jenkins配置指南01</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/03-jenkins%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%9702/>03-jenkins配置指南02</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/05-pycharm%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E9%9B%86%E6%88%90%E8%AE%BE%E7%BD%AE/>05-Pycharm代码风格集成设置</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/06-pycharm%E9%9B%86%E6%88%90%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/>06-Pycharm集成检查工具</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/08-tox%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/>08-tox集成使用指南</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/10-git_rebase/>10-git_rebase</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/celery%E7%9A%84%E4%BD%BF%E7%94%A8/>celery的使用</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/docker%E4%BD%BF%E7%94%A8/>Docker使用</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/memcached%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8/>memcached的安装和启动</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/rabbitmq%E4%BD%BF%E7%94%A8/>rabbitmq使用</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/scrapyd%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/>scrapyd使用方法</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/spiderkeeper%E6%8E%A5%E5%8F%A3/>spiderKeeper接口</a></li><li><a href=/docs/15-%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/%E5%91%BD%E4%BB%A4/>命令</a></li></ul></li><li><input type=checkbox id=section-1b4820c28a98067c0fef5225173ee99e class=toggle>
<label for=section-1b4820c28a98067c0fef5225173ee99e class="flex justify-between"><a role=button>14-docker</a></label><ul><li><a href=/docs/14-docker/01-centos7%E5%AE%89%E8%A3%85docker/>01-CentOS7安装docker</a></li><li><a href=/docs/14-docker/02-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>02-Docker常用命令</a></li><li><a href=/docs/14-docker/03-docker-compose.yaml%E9%85%8D%E7%BD%AE/>03-docker-compose</a></li></ul></li><li><input type=checkbox id=section-4a497c000e3d6340562da26fb030ea6b class=toggle>
<label for=section-4a497c000e3d6340562da26fb030ea6b class="flex justify-between"><a role=button>13-tensorflow</a></label><ul><li><a href=/docs/13-tensorflow/01-tensorflow%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/>01-tensorflow环境搭建</a></li><li><a href=/docs/13-tensorflow/02-tf%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/>02-tf基础知识和模拟线性回归</a></li><li><a href=/docs/13-tensorflow/03-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/>03-基础指令</a></li></ul></li><li><input type=checkbox id=section-601bd63086df0516f1ded16b28f48a23 class=toggle>
<label for=section-601bd63086df0516f1ded16b28f48a23 class="flex justify-between"><a role=button>12-机器学习数据分析sklearn</a></label><ul></ul></li><li><input type=checkbox id=section-572e721f6e43078bfa32034e84bbe4b4 class=toggle>
<label for=section-572e721f6e43078bfa32034e84bbe4b4 class="flex justify-between"><a role=button>11-Python设计模式</a></label><ul><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/>00-Python设计模式介绍</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/>01-工厂模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/>02-建造者模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/>03-原型模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/>04-适配器模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05-%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/>05-修饰器模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/>06-外观模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/>07-享元模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08-mvc%E6%A8%A1%E5%BC%8F/>08-MVC模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/>09-代理模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/>10-责任链模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/>11-命令模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/>12-解释器模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/>13-观察者模式</a></li><li><a href=/docs/11-python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/>14-状态模式</a></li></ul></li><li><input type=checkbox id=section-89d843abaf0e16c5973def7508f4dea9 class=toggle>
<label for=section-89d843abaf0e16c5973def7508f4dea9 class="flex justify-between"><a role=button>10-优化</a></label><ul><li><a href=/docs/10-%E4%BC%98%E5%8C%96/celery%E5%92%8Crabbitmq/>Celery和RabbitMQ</a></li><li><a href=/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/>MySQL主从分离</a></li><li><a href=/docs/10-%E4%BC%98%E5%8C%96/mysql%E4%BC%98%E5%8C%96/>MySQL优化</a></li><li><a href=/docs/10-%E4%BC%98%E5%8C%96/%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/>临时笔记</a></li><li><a href=/docs/10-%E4%BC%98%E5%8C%96/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/>单元测试</a></li></ul></li><li><input type=checkbox id=section-ffe29355398cb5e5fbcb7014db51e385 class=toggle>
<label for=section-ffe29355398cb5e5fbcb7014db51e385 class="flex justify-between"><a role=button>09-爬虫Scrapy</a></label><ul></ul></li><li><input type=checkbox id=section-db15b7fa49c62b26be2b9a42b704ae65 class=toggle>
<label for=section-db15b7fa49c62b26be2b9a42b704ae65 class="flex justify-between"><a role=button>08-Tornado</a></label><ul><li><a href=/docs/08-tornado/01-%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8Btornado/>01-基础开始tornado</a></li><li><a href=/docs/08-tornado/02-options%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/>02-options参数获取</a></li><li><a href=/docs/08-tornado/03-%E8%AF%B7%E6%B1%82%E6%A0%B8%E5%93%8D%E5%BA%9401/>03-请求核响应01</a></li><li><a href=/docs/08-tornado/%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95/>部署方法</a></li></ul></li><li><input type=checkbox id=section-34e22bee867c2ec9604e9fe143e7bc00 class=toggle>
<label for=section-34e22bee867c2ec9604e9fe143e7bc00 class="flex justify-between"><a role=button>07-Flask</a></label><ul></ul></li><li><input type=checkbox id=section-fcaf79fa010525235e9c02d2292c09e1 class=toggle>
<label for=section-fcaf79fa010525235e9c02d2292c09e1 class="flex justify-between"><a role=button>06-Django</a></label><ul></ul></li><li><input type=checkbox id=section-d2d2f644095dd7a076c04eb644e8556b class=toggle>
<label for=section-d2d2f644095dd7a076c04eb644e8556b class="flex justify-between"><a role=button>05-Linux</a></label><ul><li><a href=/docs/05-linux/01-linux%E6%93%8D%E4%BD%9C%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/>01-Linux操作,阿里云主机</a></li><li><a href=/docs/05-linux/02-linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E7%81%AB%E5%A2%99/>02-Linux安装软件服务器,防火墙</a></li><li><a href=/docs/05-linux/03-vim%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/>03-vim文本编辑器</a></li><li><a href=/docs/05-linux/04-redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/>04-redis安装配置</a></li><li><a href=/docs/05-linux/05-%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%BB%E5%8A%A1/>05-定时执行脚本任务</a></li><li><a href=/docs/05-linux/06-linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/>06-Linux操作命令</a></li><li><a href=/docs/05-linux/07-linux%E5%91%BD%E4%BB%A4cat-find/>07-Linux命令cat-find</a></li><li><a href=/docs/05-linux/08-centos7%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98/>08-Centos7虚拟机扩展磁盘</a></li><li><a href=/docs/05-linux/09-alias%E7%BC%96%E8%BE%91%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/>09-alias编辑系统命令</a></li><li><a href=/docs/05-linux/10-linux%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/>10-Linux安装工具命令</a></li><li><a href=/docs/05-linux/10-ubantu%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/>10-ubantu安装工具命令</a></li></ul></li><li><input type=checkbox id=section-4da4af1a651273d9ba8c2dff9ae4706f class=toggle>
<label for=section-4da4af1a651273d9ba8c2dff9ae4706f class="flex justify-between"><a role=button>04-数据库</a></label><ul><li><a href=/docs/04-%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%B0%8F%E7%BB%93/>各种数据库读写分离小结</a></li></ul></li><li><input type=checkbox id=section-8cca7d9cdaa4fd0ac0539752bdf7b4d6 class=toggle>
<label for=section-8cca7d9cdaa4fd0ac0539752bdf7b4d6 class="flex justify-between"><a role=button>03-Git</a></label><ul><li><a href=/docs/03-git/01-git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/>01-Git基本用法和工作流程</a></li><li><a href=/docs/03-git/02-git%E8%BF%9B%E9%98%B6/>02-Git进阶</a></li><li><a href=/docs/03-git/03-git%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/>03-Git团队开发</a></li><li><a href=/docs/03-git/04-git%E5%88%AB%E5%90%8Dalias/>04-Git别名alias</a></li><li><a href=/docs/03-git/05-gitattributes%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7/>05-gitattributes设置文件属性</a></li><li><a href=/docs/03-git/06-gitignore%E8%AE%BE%E7%BD%AE/>06-gitignore设置</a></li><li><a href=/docs/03-git/07-git_flow%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/>07-Git_Flow使用方法</a></li><li><a href=/docs/03-git/08-tox%E4%BD%BF%E7%94%A8/>08-tox使用</a></li><li><a href=/docs/03-git/09-git_rebase/>09-git_rebase</a></li><li><a href=/docs/03-git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>常用命令</a></li></ul></li><li><input type=checkbox id=section-ee5f1d736f38101aa1387ddb1895afd8 class=toggle>
<label for=section-ee5f1d736f38101aa1387ddb1895afd8 class="flex justify-between"><a role=button>02-前端HTML-js-css</a></label><ul><li><a href=/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/01-html%E6%A0%87%E7%AD%BE%E5%92%8Ccss%E6%A0%B7%E5%BC%8F%E8%A1%A8/>01-HTML标签和CSS样式表</a></li><li><a href=/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/02-javascript-jquary-ajax/>02-Javascript-JQuary-Ajax</a></li><li><a href=/docs/02-%E5%89%8D%E7%AB%AFhtml-js-css/js%E4%B8%ADcookie%E5%80%BC%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96/>js中cookie值的设置和获取</a></li></ul></li><li><input type=checkbox id=section-4ac78bf9efbed769db3bdcc4fadfc3a2 class=toggle checked>
<label for=section-4ac78bf9efbed769db3bdcc4fadfc3a2 class="flex justify-between"><a role=button>01-python基础</a></label><ul><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C-os%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%99%E6%AD%A3%E5%88%99/>01-字符串操作-os文件操作-时间日期对象-面向对象-这正则</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/02-%E5%87%BD%E6%95%B0-reduce-map-nonloca/>02-函数-reduce()-map()-nonloca</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/03-stringio/>03-stringIO</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp-udp-bs64/>04-网络编程-TCP-UDP-BS64</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/05-yield%E5%87%BD%E6%95%B0/>05-yield函数</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/06-python%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/>06-Python操作数据库</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/07-%E8%A3%85%E9%A5%B0%E5%99%A8/>07-装饰器</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/08-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/>08-递归函数</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/09-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/>09-线程和进程</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/10-%E5%8D%8F%E7%A8%8B%E5%92%8Caiohttp/ class=active>10-协程和aiohttp</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/11-%E5%85%83%E7%B1%BB/>11-元类</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/12-anaconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/>12-Anaconda创建虚拟环境</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/13-py2%E5%92%8Cpy3%E7%9A%84%E5%8C%BA%E5%88%AB/>13-py2和py3的区别</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/14-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/>14-函数的用法汇总</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/15-python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BA%93/>15-python内置函数库</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/>shell脚本语言</a></li><li><a href=/docs/01-python%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/>一些函数的用法</a></li></ul></li></ul><ul><li><a href=/posts/>博客预览</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>10-协程和aiohttp</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li><li><a href=#协程>协程</a></li><li><a href=#yield函数>yield函数</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#aiohttp>aiohttp</a><ul><li></li><li><a href=#asyncio>asyncio</a></li><li><a href=#aiohttp-1>aiohttp</a></li></ul></li><li><a href=#为tcp-sockets添加ssl控制>为TCP sockets添加SSL控制:</a></li><li><a href=#代理支持>代理支持</a></li><li><a href=#设置超时>设置超时</a></li><li><a href=#愉快地结束>愉快地结束:</a></li></ul></nav></aside></header><article class=markdown><h4 id=关于-gil>关于 GIL
<a class=anchor href=#%e5%85%b3%e4%ba%8e-gil>#</a></h4><ul><li>Pyhton的全局解释器锁</li></ul><h3 id=协程>协程
<a class=anchor href=#%e5%8d%8f%e7%a8%8b>#</a></h3><ul><li>协程其实就是一个线程， 在执行过程中， 在程序内部中断，然后转而执行别的程序，在适当的时候再返回来接着执行</li></ul><h5 id=优势>优势
<a class=anchor href=#%e4%bc%98%e5%8a%bf>#</a></h5><ul><li>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</li><li>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li><li>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</li></ul><h5 id=原因->原因 :
<a class=anchor href=#%e5%8e%9f%e5%9b%a0->#</a></h5><ul><li>cpython解释器中存在一个GIL(全局解释器锁),他的作用就是保证同一时刻只有一个线程可以执行代码,</li><li>因此造成了我们使用多线程的时候无法实现并行。</li></ul><h5 id=解决方案法->解决方案法 :
<a class=anchor href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e6%b3%95->#</a></h5><ol><li><p>更换解释器 比如使用jpython(java实现的python解释器)</p></li><li><p>使用多进程完成多任务的处理</p></li><li></li><li><p>Python语言和GIL没有关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。</p></li><li><p>GIL：</p></li></ol><p>全局解释器锁。</p><ul><li>每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。</li><li>线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后, 必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100 Python使用多进程是可以利用多核的CPU资源的。 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</li></ul><p><strong>结论</strong>:</p><ol><li>在 处理像科学计算 这类需要持续使用cpu的任务的时候 单线程会比多线程快</li><li>在 处理像IO操作等可能引起阻塞的这类任务的时候 多线程会比单线程</li></ol><h3 id=yield函数>yield函数
<a class=anchor href=#yield%e5%87%bd%e6%95%b0>#</a></h3><ul><li>生成器函数， 可以理解为暂停，程序会暂停在yield的地方， 等待下一次调用 next() 时， 程序又会执行一次， 然后继续执行</li></ul><p>可以通过打断点来进行理解， 让程序一步一步执行， 查看程序到底执行到了那里， 暂停到了那里</p><p><img src=/assets/1530151171209.png alt=53015117120></p><p>next() 让 yield 向下执行</p><p>send(n) 将值传入到 yield ， 让后向下执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>consumer</span>():
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> r
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> n:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;[CONSUMER] 消费者：</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> n)
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;CONSUMER，结束状态！&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>produce</span>(c):
</span></span><span style=display:flex><span>    next(c)  <span style=color:#75715e># 启动程序 ，让执行到 yield 处， 暂停, 等待</span>
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;n的值：</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>...&#39;</span> <span style=color:#f92672>%</span> n)
</span></span><span style=display:flex><span>        <span style=color:#75715e># 将 n 传入到 yield 中， yield r 的值 替换为 n，</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 同时 将原来的r 的值获取到， 赋值给当前的 r</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> c<span style=color:#f92672>.</span>send(n)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;r的值：</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> r)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;--&#39;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>    c<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> consumer()
</span></span><span style=display:flex><span>    produce(c)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><h3 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><ul><li>next() 激活， 向下执行</li><li>yield 暂停 停止， 并且返回值</li><li>sent() 激活 并且 替换 yield 的值</li></ul><h2 id=aiohttp>aiohttp
<a class=anchor href=#aiohttp>#</a></h2><h4 id=官方文档httpshubertroygitbooksioaiohttp-chinese-documentationcontentaiohttpe69687e6a1a3clientusagehtmle4bdbfe794a8websockets><a href=https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/aiohttp%E6%96%87%E6%A1%A3/ClientUsage.html#%E4%BD%BF%E7%94%A8WebSockets>官方文档</a>
<a class=anchor href=#%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3httpshubertroygitbooksioaiohttp-chinese-documentationcontentaiohttpe69687e6a1a3clientusagehtmle4bdbfe794a8websockets>#</a></h4><p><a href=http://aiohttp.readthedocs.io/en/stable/>http://aiohttp.readthedocs.io/en/stable/</a></p><h3 id=asyncio>asyncio
<a class=anchor href=#asyncio>#</a></h3><p>asyncio 是 Python 3.4 版本引用的标准库， 直接内置了对异步IO 的支持</p><p>asyncio的编程模式就是一个消息循环，我们从asyncio模块中直接获取一个 EventLoopd的引用， 然后把需要执行的协程扔到 EventLoop 中执行， 就实现了异步 IO，异步 IO 不会中断 CPU ，CPU 可以 继续其他的请求</p><h4 id=asynciocoroutine和anync--await效果相同-只是写法不同><code>@asyncio.coroutine</code>和<code>anync + await</code>效果相同， 只是写法不同
<a class=anchor href=#asynciocoroutine%e5%92%8canync--await%e6%95%88%e6%9e%9c%e7%9b%b8%e5%90%8c-%e5%8f%aa%e6%98%af%e5%86%99%e6%b3%95%e4%b8%8d%e5%90%8c>#</a></h4><p><code>async</code>和<code>await</code>是针对coroutine(/,kəuru:&rsquo;ti:n/)的新语法（最新添加的保留关键字），要使用新的语法，只需要做两步简单的替换：</p><ol><li>把<code>@asyncio.coroutine</code>替换为<code>async</code></li><li>把<code>yield from</code>替换为<code>await</code>。</li></ol><p>下面的函数得到相同的结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@asyncio</span><span style=color:#f92672>.</span>coroutine
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello</span>(n):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;hello, world! &#39;</span> <span style=color:#f92672>+</span> n)
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield from</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>3</span>)  <span style=color:#75715e># 等待 3s 但是程序马上启动了第二个任务</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;hello complete! &#39;</span> <span style=color:#f92672>+</span> n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>hello</span>(n):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;hello, world! &#39;</span> <span style=color:#f92672>+</span> n)
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;hello complete! &#39;</span> <span style=color:#f92672>+</span> n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>get_event_loop()
</span></span><span style=display:flex><span>task <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>wait([hello(<span style=color:#e6db74>&#39;AAAAAA&#39;</span>), hello(<span style=color:#e6db74>&#39;BBBBBB&#39;</span>)])
</span></span><span style=display:flex><span>loop<span style=color:#f92672>.</span>run_until_complete(task)
</span></span><span style=display:flex><span>loop<span style=color:#f92672>.</span>close()
</span></span></code></pre></div><p>我们可以在耗时较长的任务前中添加 <code>await</code>来让其实现多线程的并发</p><p>实际就是在 判断为耗时较长的 程序代码前 添加 <code>await</code></p><h5 id=使用自定义域名服务器>使用自定义域名服务器
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e8%87%aa%e5%ae%9a%e4%b9%89%e5%9f%9f%e5%90%8d%e6%9c%8d%e5%8a%a1%e5%99%a8>#</a></h5><h3 id=aiohttp-1>aiohttp
<a class=anchor href=#aiohttp-1>#</a></h3><p>异步 http 请求</p><p>底层需要<a href=https://aiohttp.readthedocs.io/en/stable/glossary.html#term-aiodns>aiodns</a>支持:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> aiohttp.resolver <span style=color:#f92672>import</span> AsyncResolver
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>resolver <span style=color:#f92672>=</span> AsyncResolver(nameservers<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;8.8.8.8&#34;</span>, <span style=color:#e6db74>&#34;8.8.4.4&#34;</span>])
</span></span><span style=display:flex><span>conn <span style=color:#f92672>=</span> aiohttp<span style=color:#f92672>.</span>TCPConnector(resolver<span style=color:#f92672>=</span>resolver)
</span></span></code></pre></div><h2 id=为tcp-sockets添加ssl控制>为TCP sockets添加SSL控制:
<a class=anchor href=#%e4%b8%batcp-sockets%e6%b7%bb%e5%8a%a0ssl%e6%8e%a7%e5%88%b6>#</a></h2><p>默认情况下aiohttp总会对使用了HTTPS协议(的URL请求)查验其身份。但也可将<em>verify_ssl</em>设置为<code>False</code>让其不检查:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>r <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;https://example.com&#39;</span>, verify_ssl<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span></code></pre></div><p>如果你需要设置自定义SSL信息(比如使用自己的证书文件)你可以创建一个<strong>ssl.SSLContext</strong>实例并传递到<strong>ClientSession</strong>中:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sslcontext <span style=color:#f92672>=</span> ssl<span style=color:#f92672>.</span>create_default_context(
</span></span><span style=display:flex><span>   cafile<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;/path/to/ca-bundle.crt&#39;</span>)
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;https://example.com&#39;</span>, ssl_context<span style=color:#f92672>=</span>sslcontext)
</span></span></code></pre></div><h2 id=代理支持>代理支持
<a class=anchor href=#%e4%bb%a3%e7%90%86%e6%94%af%e6%8c%81>#</a></h2><p>aiohttp 支持 HTTP/HTTPS形式的代理。你需要使用<em>proxy</em>参数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;http://python.org&#34;</span>,
</span></span><span style=display:flex><span>                           proxy<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://some.proxy.com&#34;</span>) <span style=color:#66d9ef>as</span> resp:
</span></span><span style=display:flex><span>        print(resp<span style=color:#f92672>.</span>status)
</span></span></code></pre></div><p>同时支持认证代理:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>    proxy_auth <span style=color:#f92672>=</span> aiohttp<span style=color:#f92672>.</span>BasicAuth(<span style=color:#e6db74>&#39;user&#39;</span>, <span style=color:#e6db74>&#39;pass&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;http://python.org&#34;</span>,
</span></span><span style=display:flex><span>                           proxy<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://some.proxy.com&#34;</span>,
</span></span><span style=display:flex><span>                           proxy_auth<span style=color:#f92672>=</span>proxy_auth) <span style=color:#66d9ef>as</span> resp:
</span></span><span style=display:flex><span>        print(resp<span style=color:#f92672>.</span>status)
</span></span></code></pre></div><p>也可将代理的验证信息放在url中:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;http://python.org&#34;</span>,
</span></span><span style=display:flex><span>            proxy<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://user:pass@some.proxy.com&#34;</span>)
</span></span></code></pre></div><p>与<code>requests(另一个广受欢迎的http包)</code>不同，aiohttp默认不会读取环境变量中的代理值。但你可以通过传递<code>trust_env=True</code>来让<strong>aiohttp.ClientSession</strong>读取<em>HTTP_PROXY</em>或<em>HTTPS_PROXY</em>环境变量中的代理信息(不区分大小写)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;http://python.org&#34;</span>, trust_env<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>) <span style=color:#66d9ef>as</span> resp:
</span></span><span style=display:flex><span>        print(resp<span style=color:#f92672>.</span>status)
</span></span></code></pre></div><h2 id=设置超时>设置超时
<a class=anchor href=#%e8%ae%be%e7%bd%ae%e8%b6%85%e6%97%b6>#</a></h2><p>默认情况下每个IO操作有5分钟超时时间。可以通过给<strong>ClientSession.get</strong>()及其同类组件传递<code>timeout</code>来覆盖原超时时间:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;https://github.com&#39;</span>, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>60</span>) <span style=color:#66d9ef>as</span> r:
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p><code>None</code> 或者<code>0</code>则表示不检测超时。 还可通过调用<strong>async_timeout.timeout</strong>上下文管理器来为连接和解析响应内容添加一个总超时时间:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> async_timeout
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> async_timeout<span style=color:#f92672>.</span>timeout(<span style=color:#ae81ff>0.001</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;https://github.com&#39;</span>) <span style=color:#66d9ef>as</span> r:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> r<span style=color:#f92672>.</span>text()
</span></span></code></pre></div><h2 id=愉快地结束>愉快地结束:
<a class=anchor href=#%e6%84%89%e5%bf%ab%e5%9c%b0%e7%bb%93%e6%9d%9f>#</a></h2><p>当一个包含<code>ClientSession</code>的<code>async with</code>代码块的末尾行结束时(或直接调用了<code>.close()</code>)，因为asyncio内部的一些原因底层的连接其实没有关闭。在实际使用中，底层连接需要有一个缓冲时间来关闭。然而，如果事件循环在底层连接关闭之前就结束了，那么会抛出一个 资源警告: 存在未关闭的传输(通道)(<code>ResourceWarning: unclosed transport</code>),如果警告可用的话。 为了避免这种情况，在关闭事件循环前加入一小段延迟让底层连接得到关闭的缓冲时间。 对于非SSL的<code>ClientSession</code>, 使用0即可(<code>await asyncio.sleep(0)</code>):</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li><li><a href=#协程>协程</a></li><li><a href=#yield函数>yield函数</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#aiohttp>aiohttp</a><ul><li></li><li><a href=#asyncio>asyncio</a></li><li><a href=#aiohttp-1>aiohttp</a></li></ul></li><li><a href=#为tcp-sockets添加ssl控制>为TCP sockets添加SSL控制:</a></li><li><a href=#代理支持>代理支持</a></li><li><a href=#设置超时>设置超时</a></li><li><a href=#愉快地结束>愉快地结束:</a></li></ul></nav></div></aside></main></body></html>